#!/usr/bin/env python3
"""
Test STT avec microphone r√©el - VALIDATION HUMAINE OBLIGATOIRE
üö® CONFIGURATION GPU: RTX 3090 (CUDA:1) OBLIGATOIRE
"""

import os
import sys

# =============================================================================
# üö® CONFIGURATION CRITIQUE GPU - RTX 3090 UNIQUEMENT 
# =============================================================================
os.environ['CUDA_VISIBLE_DEVICES'] = '1'        # RTX 3090 24GB EXCLUSIVEMENT
os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'  # Ordre stable des GPU
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:1024'  # Optimisation m√©moire

print("üéÆ SuperWhisper V6 Phase 4 STT - Test Microphone R√©el")
print(f"üîí CUDA_VISIBLE_DEVICES: {os.environ.get('CUDA_VISIBLE_DEVICES')}")

import asyncio
import time
import json
import numpy as np
from datetime import datetime
import sounddevice as sd
from pathlib import Path

# Ajouter le r√©pertoire parent au path pour les imports
sys.path.append(str(Path(__file__).parent.parent))

from STT.unified_stt_manager import UnifiedSTTManager

def validate_rtx3090_stt():
    """Validation syst√©matique RTX 3090 pour STT"""
    import torch
    if not torch.cuda.is_available():
        raise RuntimeError("üö´ CUDA non disponible - RTX 3090 requise pour STT")
    
    cuda_devices = os.environ.get('CUDA_VISIBLE_DEVICES', '')
    if cuda_devices != '1':
        raise RuntimeError(f"üö´ CUDA_VISIBLE_DEVICES='{cuda_devices}' incorrect - doit √™tre '1'")
    
    gpu_memory = torch.cuda.get_device_properties(0).total_memory / 1024**3
    if gpu_memory < 20:  # RTX 3090 = ~24GB
        raise RuntimeError(f"üö´ GPU ({gpu_memory:.1f}GB) trop petite - RTX 3090 requise")
    
    print(f"‚úÖ RTX 3090 valid√©e pour STT: {torch.cuda.get_device_name(0)} ({gpu_memory:.1f}GB)")

def enregistrer_audio_microphone(duree_secondes=5, sample_rate=16000):
    """
    Enregistre audio depuis le microphone syst√®me
    
    Args:
        duree_secondes: Dur√©e d'enregistrement
        sample_rate: Fr√©quence d'√©chantillonnage
        
    Returns:
        np.ndarray: Audio enregistr√© en float32
    """
    print(f"\nüé§ ENREGISTREMENT MICROPHONE - {duree_secondes}s")
    print("=" * 50)
    
    # V√©rifier les p√©riph√©riques audio disponibles
    print("üîç P√©riph√©riques audio disponibles :")
    devices = sd.query_devices()
    for i, device in enumerate(devices):
        if device['max_input_channels'] > 0:
            print(f"   {i}: {device['name']} (entr√©es: {device['max_input_channels']})")
    
    print(f"\nüéôÔ∏è Pr√©parez-vous √† parler pendant {duree_secondes} secondes...")
    input("   Appuyez sur ENTR√âE quand vous √™tes pr√™t...")
    
    print(f"\nüî¥ ENREGISTREMENT EN COURS... ({duree_secondes}s)")
    print("   Parlez maintenant dans votre microphone !")
    
    try:
        # Enregistrement
        audio_data = sd.rec(
            int(duree_secondes * sample_rate),
            samplerate=sample_rate,
            channels=1,
            dtype=np.float32
        )
        sd.wait()  # Attendre la fin de l'enregistrement
        
        print("‚úÖ Enregistrement termin√© !")
        
        # V√©rifier que l'audio n'est pas vide
        audio_flat = audio_data.flatten()
        niveau_audio = np.max(np.abs(audio_flat))
        
        if niveau_audio < 0.001:
            print("‚ö†Ô∏è  ATTENTION: Niveau audio tr√®s faible - v√©rifiez votre microphone")
        else:
            print(f"üìä Niveau audio d√©tect√©: {niveau_audio:.3f}")
        
        return audio_flat
        
    except Exception as e:
        print(f"‚ùå Erreur enregistrement: {e}")
        return None

async def test_stt_microphone_reel():
    """
    Test STT avec microphone r√©el et validation humaine obligatoire
    """
    print("\n" + "=" * 60)
    print("üéß TEST STT MICROPHONE R√âEL - VALIDATION HUMAINE OBLIGATOIRE")
    print("=" * 60)
    
    # Validation GPU obligatoire
    validate_rtx3090_stt()
    
    # Initialiser STT Manager
    print("\nüîß Initialisation UnifiedSTTManager...")
    stt_manager = UnifiedSTTManager()
    
    # Tests √† r√©aliser
    tests_microphone = [
        {
            "nom": "Test Phrase Courte",
            "duree": 3,
            "instruction": "Dites une phrase courte et claire (ex: 'Bonjour, comment allez-vous ?')"
        },
        {
            "nom": "Test Phrase Longue", 
            "duree": 8,
            "instruction": "Dites une phrase longue avec plusieurs mots (ex: description de votre journ√©e)"
        },
        {
            "nom": "Test Mots Techniques",
            "duree": 5,
            "instruction": "Dites des mots techniques (ex: 'intelligence artificielle', 'apprentissage automatique')"
        }
    ]
    
    resultats_validation = []
    
    for i, test in enumerate(tests_microphone, 1):
        print(f"\n{'='*60}")
        print(f"üéØ TEST {i}/{len(tests_microphone)} : {test['nom']}")
        print(f"üìù Instruction : {test['instruction']}")
        print(f"‚è±Ô∏è Dur√©e : {test['duree']} secondes")
        print("=" * 60)
        
        # Enregistrement microphone
        audio_data = enregistrer_audio_microphone(test['duree'])
        
        if audio_data is None:
            print(f"‚ùå √âchec enregistrement pour {test['nom']}")
            continue
        
        # Transcription STT
        print(f"\nü§ñ TRANSCRIPTION STT EN COURS...")
        start_time = time.time()
        
        try:
            result = await stt_manager.transcribe(audio_data)
            latence_ms = (time.time() - start_time) * 1000
            
            print(f"‚úÖ Transcription termin√©e en {latence_ms:.0f}ms")
            print(f"üìù Texte transcrit : '{result.text}'")
            print(f"üìä Confiance : {result.confidence:.2f}")
            print(f"‚ö° RTF : {result.rtf:.3f}")
            print(f"üéÆ Backend utilis√© : {result.backend_used}")
            
            # üéß VALIDATION HUMAINE OBLIGATOIRE
            print("\n" + "="*60)
            print("üéß VALIDATION HUMAINE AUDIO OBLIGATOIRE")
            print("="*60)
            
            print("üëÇ √âCOUTEZ ATTENTIVEMENT et √©valuez la transcription :")
            print(f"   üé§ Ce que vous avez dit : [√Ä compl√©ter]")
            print(f"   ü§ñ Ce que le STT a transcrit : '{result.text}'")
            print()
            
            # Saisie validation humaine
            phrase_reelle = input("üé§ Tapez exactement ce que vous avez dit : ")
            
            while True:
                precision = input("üéØ Pr√©cision transcription (excellent/bon/acceptable/insuffisant) : ").lower()
                if precision in ['excellent', 'bon', 'acceptable', 'insuffisant']:
                    break
                print("‚ùå R√©ponse invalide. Utilisez : excellent/bon/acceptable/insuffisant")
            
            while True:
                latence_percue = input("‚è±Ô∏è Latence per√ßue (imperceptible/acceptable/g√™nante) : ").lower()
                if latence_percue in ['imperceptible', 'acceptable', 'g√™nante']:
                    break
                print("‚ùå R√©ponse invalide. Utilisez : imperceptible/acceptable/g√™nante")
            
            commentaires = input("üí¨ Commentaires d√©taill√©s (optionnel) : ")
            
            # Validation finale
            while True:
                validation = input("üéØ Validation finale (valid√©/√†_corriger/valid√©_avec_r√©serves) : ").lower()
                if validation in ['valid√©', '√†_corriger', 'valid√©_avec_r√©serves']:
                    break
                print("‚ùå R√©ponse invalide. Utilisez : valid√©/√†_corriger/valid√©_avec_r√©serves")
            
            # Calculer pr√©cision approximative
            if phrase_reelle.strip():
                mots_reels = phrase_reelle.lower().split()
                mots_transcrits = result.text.lower().split()
                
                # Calcul simple de pr√©cision (mots en commun)
                mots_communs = set(mots_reels) & set(mots_transcrits)
                precision_calculee = len(mots_communs) / max(len(mots_reels), 1) * 100
            else:
                precision_calculee = 0
            
            # Enregistrer r√©sultat validation
            resultats_validation.append({
                "test": test['nom'],
                "phrase_reelle": phrase_reelle,
                "texte_transcrit": result.text,
                "latence_ms": latence_ms,
                "rtf": result.rtf,
                "confiance": result.confidence,
                "backend_utilise": result.backend_used,
                "precision_humaine": precision,
                "precision_calculee": precision_calculee,
                "latence_percue": latence_percue,
                "commentaires": commentaires,
                "validation_finale": validation,
                "timestamp": datetime.now().isoformat()
            })
            
            print(f"\n‚úÖ Validation {validation.upper()} enregistr√©e")
            print(f"üìä Pr√©cision calcul√©e : {precision_calculee:.1f}%")
            
        except Exception as e:
            print(f"‚ùå Erreur transcription : {e}")
            resultats_validation.append({
                "test": test['nom'],
                "erreur": str(e),
                "validation_finale": "√©chec",
                "timestamp": datetime.now().isoformat()
            })
    
    # Rapport final validation humaine
    print("\n" + "="*80)
    print("üìä RAPPORT FINAL VALIDATION HUMAINE MICROPHONE R√âEL")
    print("="*80)
    
    validations_reussies = 0
    precision_moyenne = 0
    latence_moyenne = 0
    
    for i, result in enumerate(resultats_validation, 1):
        print(f"\nüéØ TEST {i} - {result['test']} :")
        if 'erreur' not in result:
            print(f"   üé§ Phrase r√©elle : '{result['phrase_reelle']}'")
            print(f"   ü§ñ Transcription : '{result['texte_transcrit']}'")
            print(f"   ‚è±Ô∏è Latence : {result['latence_ms']:.0f}ms")
            print(f"   üìä Pr√©cision calcul√©e : {result['precision_calculee']:.1f}%")
            print(f"   üéØ Pr√©cision humaine : {result['precision_humaine']}")
            print(f"   ‚è±Ô∏è Latence per√ßue : {result['latence_percue']}")
            print(f"   ‚úÖ Validation : {result['validation_finale']}")
            print(f"   üéÆ Backend : {result['backend_utilise']}")
            if result['commentaires']:
                print(f"   üí¨ Commentaires : {result['commentaires']}")
            
            if result['validation_finale'] == 'valid√©':
                validations_reussies += 1
            
            precision_moyenne += result['precision_calculee']
            latence_moyenne += result['latence_ms']
        else:
            print(f"   ‚ùå Erreur : {result['erreur']}")
    
    # Statistiques finales
    if resultats_validation:
        precision_moyenne /= len(resultats_validation)
        latence_moyenne /= len(resultats_validation)
        taux_reussite = (validations_reussies / len(resultats_validation)) * 100
        
        print(f"\nüìà STATISTIQUES FINALES :")
        print(f"   üéØ Taux de r√©ussite : {taux_reussite:.1f}% ({validations_reussies}/{len(resultats_validation)})")
        print(f"   üìä Pr√©cision moyenne : {precision_moyenne:.1f}%")
        print(f"   ‚è±Ô∏è Latence moyenne : {latence_moyenne:.0f}ms")
        
        # √âvaluation globale
        if taux_reussite >= 80 and precision_moyenne >= 90:
            print(f"\nüéâ √âVALUATION GLOBALE : EXCELLENT !")
        elif taux_reussite >= 60 and precision_moyenne >= 80:
            print(f"\n‚úÖ √âVALUATION GLOBALE : BON")
        elif taux_reussite >= 40 and precision_moyenne >= 70:
            print(f"\n‚ö†Ô∏è √âVALUATION GLOBALE : ACCEPTABLE")
        else:
            print(f"\n‚ùå √âVALUATION GLOBALE : √Ä AM√âLIORER")
    
    # Sauvegarder rapport
    os.makedirs('test_output', exist_ok=True)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    rapport_file = f'test_output/validation_microphone_reel_{timestamp}.json'
    
    with open(rapport_file, 'w', encoding='utf-8') as f:
        json.dump(resultats_validation, f, indent=2, ensure_ascii=False)
    
    print(f"\nüíæ Rapport sauvegard√© : {rapport_file}")
    print("\nüéä VALIDATION HUMAINE MICROPHONE R√âEL TERMIN√âE")
    
    return resultats_validation

async def main():
    """Point d'entr√©e principal"""
    try:
        resultats = await test_stt_microphone_reel()
        print(f"\n‚úÖ Tests microphone termin√©s avec {len(resultats)} validations")
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Tests interrompus par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur lors des tests : {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(main()) 