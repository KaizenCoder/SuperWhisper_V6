#!/usr/bin/env python3
"""
Validation TTS SuperWhisper V6 - Test Individuel
===============================================
‚Ä¢ Test TTS uniquement : UnifiedTTSManager
‚Ä¢ Validation audio g√©n√©r√© et lecture
‚Ä¢ Configuration RTX 3090 obligatoire
‚Ä¢ Pas d'autres composants (STT/LLM)

Ex√©cution :
```
python tests/test_tts_validation.py
```
"""

from __future__ import annotations

import os
import sys
import time
from pathlib import Path
from typing import Any, Dict

import numpy as np
import sounddevice as sd

# =============================================================================
# üö® CONFIGURATION CRITIQUE GPU - RTX 3090 UNIQUEMENT 
# =============================================================================
os.environ['CUDA_VISIBLE_DEVICES'] = '1'        # RTX 3090 24GB EXCLUSIVEMENT
os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'  # Ordre stable des GPU
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:1024'  # Optimisation m√©moire

print("üéÆ GPU Configuration: RTX 3090 (CUDA:1) forc√©e")
print(f"üîí CUDA_VISIBLE_DEVICES: {os.environ.get('CUDA_VISIBLE_DEVICES')}")

# ---------------------------------------------------------------------------
# Configuration projet
# ---------------------------------------------------------------------------
PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(PROJECT_ROOT / "TTS"))

def validate_rtx3090_configuration():
    """Validation obligatoire de la configuration RTX 3090"""
    try:
        import torch
        if not torch.cuda.is_available():
            raise RuntimeError("üö´ CUDA non disponible - RTX 3090 requise")
        
        cuda_devices = os.environ.get('CUDA_VISIBLE_DEVICES', '')
        if cuda_devices != '1':
            raise RuntimeError(f"üö´ CUDA_VISIBLE_DEVICES='{cuda_devices}' incorrect - doit √™tre '1'")
        
        gpu_memory = torch.cuda.get_device_properties(0).total_memory / 1024**3
        if gpu_memory < 20:  # RTX 3090 = ~24GB
            raise RuntimeError(f"üö´ GPU ({gpu_memory:.1f}GB) trop petite - RTX 3090 requise")
        
        print(f"‚úÖ RTX 3090 valid√©e: {torch.cuda.get_device_name(0)} ({gpu_memory:.1f}GB)")
        return True, torch.cuda.get_device_name(0), gpu_memory
    except Exception as e:
        print(f"‚ö†Ô∏è Validation GPU √©chou√©e: {e}")
        return False, str(e), 0

def _to_int16(audio_f: np.ndarray) -> np.ndarray:
    """Conversion audio float vers int16 s√©curis√©e"""
    audio_c = np.clip(audio_f, -1.0, 1.0)
    return (audio_c * 32767).astype(np.int16)

def test_tts_individual():
    """Test TTS individuel avec texte simple"""
    
    print("\n‚ñà‚ñà‚ñà‚ñà  SuperWhisper V6 ‚Äì Test TTS Individuel  ‚ñà‚ñà‚ñà‚ñà")
    
    # =========================================================================
    # √âTAPE 1: VALIDATION GPU RTX 3090
    # =========================================================================
    print("\nüîß √âTAPE 1: VALIDATION GPU RTX 3090")
    gpu_ok, gpu_name, gpu_memory = validate_rtx3090_configuration()
    
    if not gpu_ok:
        print("‚ùå Validation GPU √©chou√©e - Arr√™t du test")
        return False

    # =========================================================================
    # √âTAPE 2: INITIALISATION TTS
    # =========================================================================
    print("\nüîß √âTAPE 2: INITIALISATION TTS")
    
    try:
        from tts_manager import UnifiedTTSManager
        
        print("üîÑ Initialisation UnifiedTTSManager...")
        tts_manager = UnifiedTTSManager()
        print("‚úÖ UnifiedTTSManager initialis√©")
        
    except Exception as e:
        print(f"‚ùå Erreur initialisation TTS: {e}")
        return False

    # =========================================================================
    # √âTAPE 3: TEST SYNTH√àSE VOCALE
    # =========================================================================
    print("\nüîä √âTAPE 3: TEST SYNTH√àSE VOCALE")
    
    test_text = "Bonjour ! Je suis SuperWhisper V6, votre assistant vocal."
    print(f"üìù Texte √† synth√©tiser: '{test_text}'")
    
    try:
        print("üîÑ Synth√®se en cours...")
        start_time = time.perf_counter()
        
        # Appel TTS
        result = tts_manager.synthesize(test_text)
        
        end_time = time.perf_counter()
        latency_ms = (end_time - start_time) * 1000
        
        # V√©rification r√©sultat
        if isinstance(result, tuple):
            audio_data, sample_rate = result
        else:
            audio_data = result
            sample_rate = getattr(tts_manager, 'sample_rate', 22050)
        
        print(f"‚úÖ Synth√®se r√©ussie: {len(audio_data):,} √©chantillons")
        print(f"‚ö° Latence TTS: {latency_ms:.1f}ms")
        print(f"üéµ Sample rate: {sample_rate}Hz")
        print(f"‚è±Ô∏è Dur√©e audio: {len(audio_data) / sample_rate:.1f}s")
        
    except Exception as e:
        print(f"‚ùå Erreur synth√®se TTS: {e}")
        return False

    # =========================================================================
    # √âTAPE 4: LECTURE AUDIO
    # =========================================================================
    print("\nüîà √âTAPE 4: LECTURE AUDIO")
    
    try:
        print("üîÑ Conversion et lecture audio...")
        
        # Conversion s√©curis√©e
        audio_i16 = _to_int16(audio_data)
        
        print("üîä Lecture audio - √âcoutez attentivement...")
        sd.play(audio_i16, samplerate=sample_rate)
        sd.wait()
        
        print("‚úÖ Audio jou√© avec succ√®s")
        
    except Exception as e:
        print(f"‚ùå Erreur lecture audio: {e}")
        return False

    # =========================================================================
    # VALIDATION HUMAINE
    # =========================================================================
    print("\n" + "="*60)
    print("üßë VALIDATION HUMAINE TTS")
    print("="*60)
    print(f"üìù Texte synth√©tis√©: '{test_text}'")
    print(f"‚ö° Latence TTS: {latency_ms:.1f}ms")
    print(f"üéµ Dur√©e audio: {len(audio_data) / sample_rate:.1f}s")
    print(f"üéÆ GPU utilis√©e: {gpu_name}")
    
    # Questions validation
    questions = [
        "Avez-vous entendu l'audio TTS ?",
        "La voix est-elle claire et compr√©hensible ?", 
        "La latence TTS est-elle acceptable ?",
        "Le TTS fonctionne-t-il correctement ?"
    ]
    
    all_ok = True
    for question in questions:
        response = input(f"‚ùì {question} (y/n): ").strip().lower()
        if not response.startswith("y"):
            all_ok = False
    
    # Verdict final
    print("\n" + "="*60)
    if all_ok:
        print("‚úÖ VALIDATION TTS : SUCC√àS")
        print("üéä TTS SuperWhisper V6 VALID√â !")
        print("="*60)
        return True
    else:
        print("‚ùå VALIDATION TTS : √âCHEC")
        print("üîß TTS n√©cessite des corrections")
        print("="*60)
        return False

if __name__ == "__main__":
    try:
        success = test_tts_individual()
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"\n‚ùå ERREUR CRITIQUE: {e}")
        sys.exit(1) 