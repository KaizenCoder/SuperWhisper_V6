#!/usr/bin/env python3
"""
Validation Humaine Pipeline - TTS EXISTANT INCHANGÃ‰
ðŸš¨ CONFIGURATION GPU: RTX 3090 (CUDA:1) OBLIGATOIRE

UTILISE LE TTS EXISTANT TEL QUEL - AUCUNE MODIFICATION
Pipeline complet : Mic â†’ STT â†’ LLM â†’ TTS â†’ Audio
"""

import os
import sys
import asyncio
import time
import json
from pathlib import Path

# =============================================================================
# ðŸš¨ CONFIGURATION CRITIQUE GPU - RTX 3090 UNIQUEMENT 
# =============================================================================
os.environ['CUDA_VISIBLE_DEVICES'] = '1'        # RTX 3090 24GB EXCLUSIVEMENT
os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'  # Ordre stable des GPU
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:1024'  # Optimisation mÃ©moire

print("ðŸŽ® GPU Configuration: RTX 3090 (CUDA:1) forcÃ©e")
print(f"ðŸ”’ CUDA_VISIBLE_DEVICES: {os.environ.get('CUDA_VISIBLE_DEVICES')}")

# Imports
sys.path.insert(0, '.')

def validate_rtx3090_configuration():
    """Validation obligatoire de la configuration RTX 3090"""
    try:
        import torch
        if not torch.cuda.is_available():
            raise RuntimeError("ðŸš« CUDA non disponible - RTX 3090 requise")
        
        cuda_devices = os.environ.get('CUDA_VISIBLE_DEVICES', '')
        if cuda_devices != '1':
            raise RuntimeError(f"ðŸš« CUDA_VISIBLE_DEVICES='{cuda_devices}' incorrect - doit Ãªtre '1'")
        
        gpu_memory = torch.cuda.get_device_properties(0).total_memory / 1024**3
        if gpu_memory < 20:  # RTX 3090 = ~24GB
            raise RuntimeError(f"ðŸš« GPU ({gpu_memory:.1f}GB) trop petite - RTX 3090 requise")
        
        print(f"âœ… RTX 3090 validÃ©e: {torch.cuda.get_device_name(0)} ({gpu_memory:.1f}GB)")
        return True
    except Exception as e:
        print(f"âš ï¸ Validation GPU Ã©chouÃ©e: {e}")
        return False

async def test_pipeline_complet_existant():
    """Test pipeline complet avec TTS existant inchangÃ©"""
    print("\nðŸš€ VALIDATION HUMAINE PIPELINE COMPLET")
    print("ðŸ”§ UTILISE TTS EXISTANT TEL QUEL - AUCUNE MODIFICATION")
    print("=" * 60)
    
    # Validation GPU obligatoire
    if not validate_rtx3090_configuration():
        print("ðŸš« Ã‰CHEC: Configuration GPU RTX 3090 invalide")
        return False
    
    try:
        # Import du pipeline existant
        from PIPELINE.pipeline_orchestrator import PipelineOrchestrator
        
        print("âœ… Import PipelineOrchestrator rÃ©ussi")
        
        # Configuration pipeline existante
        config_path = Path("PIPELINE/config/pipeline.yaml")
        if not config_path.exists():
            print(f"âš ï¸ Config pipeline non trouvÃ©e: {config_path}")
            # Utilisation config par dÃ©faut
            config = {}
        else:
            import yaml
            with open(config_path, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
            print(f"âœ… Configuration chargÃ©e: {config_path}")
        
        # Import TTS existant INCHANGÃ‰
        from TTS.tts_manager import UnifiedTTSManager
        
        # Configuration TTS existante
        tts_config_path = Path("config/tts.yaml")
        if tts_config_path.exists():
            with open(tts_config_path, 'r', encoding='utf-8') as f:
                tts_config = yaml.safe_load(f)
        else:
            # Config minimale pour TTS existant
            tts_config = {}
        
        print("ðŸ”§ Initialisation TTS existant...")
        tts_manager = UnifiedTTSManager(tts_config)
        
        # Initialisation pipeline avec TTS existant
        print("ðŸ”§ Initialisation PipelineOrchestrator avec TTS existant...")
        pipeline = PipelineOrchestrator(config, tts_manager)
        
        # Test simple TTS via pipeline
        test_text = "Bonjour, test de validation humaine SuperWhisper V6."
        print(f"ðŸ“ Texte test: {test_text}")
        
        print("ðŸŽµ Test TTS via pipeline...")
        start_time = time.time()
        
        # Utilisation TTS existant via pipeline
        print("ðŸŽµ SynthÃ¨se TTS via TTS existant...")
        tts_result = await tts_manager.synthesize(test_text)
        
        end_time = time.time()
        latency_ms = (end_time - start_time) * 1000
        
        # Validation rÃ©sultat
        if tts_result and tts_result.success and tts_result.audio_data:
            print(f"âœ… TTS PIPELINE SUCCÃˆS!")
            print(f"ðŸŽ¯ Backend utilisÃ©: {tts_result.backend_used}")
            print(f"âš¡ Latence: {latency_ms:.1f}ms")
            print(f"ðŸ”Š Audio gÃ©nÃ©rÃ©: {len(tts_result.audio_data):,} bytes")
            
            # Sauvegarde audio pour validation humaine
            output_file = Path("PIPELINE/test_output/validation_humaine_pipeline.wav")
            output_file.parent.mkdir(exist_ok=True)
            
            with open(output_file, 'wb') as f:
                f.write(tts_result.audio_data)
            
            print(f"ðŸ’¾ Audio sauvegardÃ©: {output_file}")
            
            # Lecture audio automatique
            try:
                import pygame
                pygame.mixer.init()
                pygame.mixer.music.load(str(output_file))
                pygame.mixer.music.play()
                print("ðŸ”Š Lecture audio automatique...")
                
                # Attendre fin lecture
                while pygame.mixer.music.get_busy():
                    await asyncio.sleep(0.1)
                    
            except Exception as e:
                print(f"âš ï¸ Lecture automatique Ã©chouÃ©e: {e}")
                print("ðŸ”Š Veuillez lire manuellement le fichier audio")
            
            # Validation humaine
            print("\n" + "="*60)
            print("ðŸŽ§ VALIDATION HUMAINE PIPELINE COMPLET")
            print("="*60)
            print(f"ðŸ“ Fichier audio: {output_file}")
            print("ðŸ”Š Audio lu automatiquement (ou manuellement)")
            print("â“ Avez-vous entendu une vraie voix franÃ§aise ?")
            print("â“ Le pipeline TTS fonctionne-t-il correctement ?")
            
            response = input("âœ… Validation pipeline (o/n): ").strip().lower()
            
            if response in ['o', 'oui', 'y', 'yes']:
                print("ðŸŽŠ VALIDATION HUMAINE PIPELINE RÃ‰USSIE!")
                
                # MÃ©triques finales
                metrics = {
                    "validation_time": time.strftime("%Y-%m-%d %H:%M:%S"),
                    "pipeline_test": "SUCCESS",
                    "backend_used": tts_result.backend_used,
                    "latency_ms": latency_ms,
                    "audio_size_bytes": len(tts_result.audio_data),
                    "gpu_config": "RTX 3090 (CUDA:1)",
                    "human_validation": "SUCCESS",
                    "tts_modified": False,  # TTS non modifiÃ©
                    "pipeline_integration": True
                }
                
                metrics_file = Path("PIPELINE/reports/validation_humaine_pipeline.json")
                metrics_file.parent.mkdir(exist_ok=True)
                
                with open(metrics_file, 'w', encoding='utf-8') as f:
                    json.dump(metrics, f, indent=2, ensure_ascii=False)
                
                print(f"ðŸ“Š MÃ©triques sauvegardÃ©es: {metrics_file}")
                return True
            else:
                print("âŒ VALIDATION HUMAINE PIPELINE Ã‰CHOUÃ‰E")
                return False
                
        else:
            print("ðŸš« Ã‰CHEC TTS PIPELINE: Aucun audio gÃ©nÃ©rÃ©")
            if tts_result:
                print(f"âŒ Erreur: {tts_result.error}")
            return False
            
    except Exception as e:
        print(f"ðŸ’¥ ERREUR PIPELINE: {e}")
        import traceback
        traceback.print_exc()
        return False

async def main():
    """Point d'entrÃ©e principal"""
    print("ðŸŽ¯ VALIDATION HUMAINE PIPELINE COMPLET")
    print("ðŸš¨ RTX 3090 (CUDA:1) OBLIGATOIRE")
    print("ðŸ”§ TTS EXISTANT INCHANGÃ‰ - AUCUNE MODIFICATION")
    print()
    
    success = await test_pipeline_complet_existant()
    
    if success:
        print("\nðŸŽŠ SUCCÃˆS COMPLET - PIPELINE VALIDÃ‰!")
        print("âœ… TTS existant fonctionne via pipeline")
        print("âœ… Validation humaine confirmÃ©e")
        print("âœ… TÃ¢che 4 peut Ãªtre marquÃ©e terminÃ©e")
    else:
        print("\nâŒ Ã‰CHEC - Pipeline non validÃ©")
        print("ðŸ”§ ProblÃ¨me d'intÃ©gration pipeline/TTS")
    
    return success

if __name__ == "__main__":
    asyncio.run(main()) 