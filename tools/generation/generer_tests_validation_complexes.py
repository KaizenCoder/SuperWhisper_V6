#!/usr/bin/env python3
"""
G√©n√©ration tests validation complexes - SuperWhisper V6 TTS
G√©n√®re des fichiers audio avec textes de validation de complexit√© croissante

üö® CONFIGURATION GPU: RTX 3090 (CUDA:1) OBLIGATOIRE
"""

import os
import sys
import pathlib

# =============================================================================
# üöÄ PORTABILIT√â AUTOMATIQUE - EX√âCUTABLE DEPUIS N'IMPORTE O√ô
# =============================================================================
def _setup_portable_environment():
    """Configure l'environnement pour ex√©cution portable"""
    # D√©terminer le r√©pertoire racine du projet
    current_file = pathlib.Path(__file__).resolve()
    
    # Chercher le r√©pertoire racine (contient .git ou marqueurs projet)
    project_root = current_file
    for parent in current_file.parents:
        if any((parent / marker).exists() for marker in ['.git', 'pyproject.toml', 'requirements.txt', '.taskmaster']):
            project_root = parent
            break
    
    # Ajouter le projet root au Python path
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))
    
    # Changer le working directory vers project root
    os.chdir(project_root)
    
    # Configuration GPU RTX 3090 obligatoire
    os.environ['CUDA_VISIBLE_DEVICES'] = '1'        # RTX 3090 24GB EXCLUSIVEMENT
    os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'  # Ordre stable des GPU
    
    print(f"üéÆ GPU Configuration: RTX 3090 (CUDA:1) forc√©e")
    print(f"üìÅ Project Root: {project_root}")
    print(f"üíª Working Directory: {os.getcwd()}")
    
    return project_root

# Initialiser l'environnement portable
_PROJECT_ROOT = _setup_portable_environment()

# Maintenant imports normaux...

import asyncio
import yaml
import time
from pathlib import Path

# =============================================================================
# üö® CONFIGURATION CRITIQUE GPU - RTX 3090 UNIQUEMENT 
# =============================================================================
os.environ['CUDA_VISIBLE_DEVICES'] = '1'
os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:1024'

print("üéÆ GPU Configuration: RTX 3090 (CUDA:1) forc√©e")
print(f"üîí CUDA_VISIBLE_DEVICES: {os.environ.get('CUDA_VISIBLE_DEVICES')}")

# Import du syst√®me TTS
from TTS.tts_manager import UnifiedTTSManager
from TTS.utils_audio import is_valid_wav, get_wav_info

# Textes de validation complexes
TEXTE_VALIDATION_1 = """Bonjour, ceci est un test de validation pour SuperWhisper2. Je vais maintenant √©noncer plusieurs phrases de complexit√© croissante pour √©valuer la pr√©cision de transcription.
Premi√®rement, des mots simples : chat, chien, maison, voiture, ordinateur, t√©l√©phone.
Deuxi√®mement, des phrases courtes : Il fait beau aujourd'hui. Le caf√© est d√©licieux. J'aime la musique classique.
Troisi√®mement, des phrases plus complexes : L'intelligence artificielle transforme notre mani√®re de travailler et de communiquer dans le monde moderne.
Quatri√®mement, des termes techniques : algorithme, machine learning, GPU RTX 3090, faster-whisper, quantification INT8, latence de transcription."""

TEXTE_VALIDATION_2 = """Cinqui√®mement, des nombres et dates : vingt-trois, quarante-sept, mille neuf cent quatre-vingt-quinze, le quinze janvier deux mille vingt-quatre.
Sixi√®mement, des mots difficiles : chrysanth√®me, anticonstitutionnellement, prestidigitateur, kak√©mono, yaourt.
Septi√®mement, une phrase longue et complexe : L'optimisation des performances de transcription vocale n√©cessite une approche m√©thodique combinant la s√©lection appropri√©e des mod√®les, l'ajustement des param√®tres de traitement, et l'impl√©mentation d'algorithmes de post-traitement pour am√©liorer la qualit√© du r√©sultat final.
Fin du test de validation."""

async def generer_fichier_tts(manager, texte, nom_fichier, backend_specifique=None):
    """G√©n√®re un fichier TTS avec validation compl√®te"""
    print(f"\nüéØ G√©n√©ration: {nom_fichier}")
    print("-" * 50)
    
    try:
        start_time = time.perf_counter()
        
        if backend_specifique:
            # Test backend sp√©cifique
            handler = manager.handlers.get(backend_specifique)
            if not handler:
                print(f"‚ùå Backend {backend_specifique.value} non disponible")
                return False
            
            audio_data = await handler.synthesize(texte)
            backend_used = backend_specifique.value
        else:
            # Test manager unifi√©
            result = await manager.synthesize(texte)
            if not result.success:
                print(f"‚ùå √âchec synth√®se: {result.error}")
                return False
            
            audio_data = result.audio_data
            backend_used = result.backend_used
        
        latency_ms = (time.perf_counter() - start_time) * 1000
        
        # Validation format
        if not is_valid_wav(audio_data):
            print(f"‚ùå Format WAV invalide")
            return False
        
        wav_info = get_wav_info(audio_data)
        
        # Sauvegarde fichier
        output_dir = Path("test_output")
        output_dir.mkdir(exist_ok=True)
        
        output_file = output_dir / nom_fichier
        with open(output_file, 'wb') as f:
            f.write(audio_data)
        
        # Affichage r√©sultats
        print(f"‚úÖ SUCC√àS")
        print(f"   Backend: {backend_used}")
        print(f"   Latence: {latency_ms:.1f}ms")
        print(f"   Taille: {len(audio_data)} bytes ({len(audio_data)/1024:.1f}KB)")
        
        if 'error' not in wav_info:
            print(f"   Dur√©e: {wav_info.get('duration_ms', 'N/A')}ms")
            print(f"   Qualit√©: {wav_info.get('framerate', 'N/A')} Hz, {wav_info.get('channels', 'N/A')} canaux")
        
        print(f"   Fichier: {output_file}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå ERREUR: {e}")
        return False

async def generer_tests_validation_complexes():
    """G√©n√®re tous les tests de validation complexes"""
    print("\nüß™ G√âN√âRATION TESTS VALIDATION COMPLEXES - SUPERWHISPER V6")
    print("=" * 70)
    
    # Chargement configuration
    config_path = Path("config/tts.yaml")
    with open(config_path, 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    
    # Initialisation manager
    print("üìã Initialisation UnifiedTTSManager...")
    manager = UnifiedTTSManager(config)
    
    print(f"üéØ Backends disponibles: {len(manager.handlers)}")
    for backend_type in manager.handlers.keys():
        print(f"   - {backend_type.value}")
    
    # Tests √† g√©n√©rer
    tests = [
        # Tests avec manager unifi√© (fallback automatique)
        {
            'texte': TEXTE_VALIDATION_1,
            'nom': 'validation_complexe_partie1_unifie.wav',
            'backend': None,
            'description': 'Partie 1 - Manager unifi√© (mots simples ‚Üí termes techniques)'
        },
        {
            'texte': TEXTE_VALIDATION_2,
            'nom': 'validation_complexe_partie2_unifie.wav',
            'backend': None,
            'description': 'Partie 2 - Manager unifi√© (nombres ‚Üí phrase complexe)'
        },
        
        # Tests avec backends sp√©cifiques
        {
            'texte': TEXTE_VALIDATION_1,
            'nom': 'validation_complexe_partie1_piper_native.wav',
            'backend': 'piper_native',
            'description': 'Partie 1 - Piper Native GPU'
        },
        {
            'texte': TEXTE_VALIDATION_2,
            'nom': 'validation_complexe_partie2_piper_native.wav',
            'backend': 'piper_native',
            'description': 'Partie 2 - Piper Native GPU'
        },
        {
            'texte': TEXTE_VALIDATION_1,
            'nom': 'validation_complexe_partie1_piper_cli.wav',
            'backend': 'piper_cli',
            'description': 'Partie 1 - Piper CLI CPU'
        },
        {
            'texte': TEXTE_VALIDATION_2,
            'nom': 'validation_complexe_partie2_piper_cli.wav',
            'backend': 'piper_cli',
            'description': 'Partie 2 - Piper CLI CPU'
        },
        {
            'texte': TEXTE_VALIDATION_1,
            'nom': 'validation_complexe_partie1_sapi.wav',
            'backend': 'sapi_french',
            'description': 'Partie 1 - SAPI French'
        },
        {
            'texte': TEXTE_VALIDATION_2,
            'nom': 'validation_complexe_partie2_sapi.wav',
            'backend': 'sapi_french',
            'description': 'Partie 2 - SAPI French'
        }
    ]
    
    # Statistiques
    total_tests = len(tests)
    success_count = 0
    error_count = 0
    
    print(f"\nüéØ G√©n√©ration de {total_tests} fichiers de test...")
    print("=" * 70)
    
    # G√©n√©ration de tous les tests
    for i, test in enumerate(tests, 1):
        print(f"\nüìã TEST {i}/{total_tests}: {test['description']}")
        print(f"üìù Texte: {len(test['texte'])} caract√®res")
        
        # Conversion backend string vers enum si n√©cessaire
        backend_enum = None
        if test['backend']:
            from TTS.tts_manager import TTSBackendType
            backend_map = {
                'piper_native': TTSBackendType.PIPER_NATIVE,
                'piper_cli': TTSBackendType.PIPER_CLI,
                'sapi_french': TTSBackendType.SAPI_FRENCH,
                'silent_emergency': TTSBackendType.SILENT_EMERGENCY
            }
            backend_enum = backend_map.get(test['backend'])
        
        # G√©n√©ration
        success = await generer_fichier_tts(
            manager, 
            test['texte'], 
            test['nom'], 
            backend_enum
        )
        
        if success:
            success_count += 1
        else:
            error_count += 1
    
    # G√©n√©ration fichier complet (combin√©)
    print(f"\nüéØ G√âN√âRATION FICHIER COMPLET COMBIN√â")
    print("-" * 50)
    
    texte_complet = TEXTE_VALIDATION_1 + "\n\n" + TEXTE_VALIDATION_2
    success_complet = await generer_fichier_tts(
        manager,
        texte_complet,
        'validation_complexe_complet.wav'
    )
    
    if success_complet:
        success_count += 1
        total_tests += 1
    else:
        error_count += 1
        total_tests += 1
    
    # R√©sum√© final
    print(f"\nüìä R√âSUM√â G√âN√âRATION TESTS VALIDATION")
    print("=" * 70)
    print(f"Tests g√©n√©r√©s avec succ√®s: {success_count}/{total_tests}")
    print(f"Erreurs: {error_count}")
    print(f"Taux de r√©ussite: {success_count/total_tests*100:.1f}%")
    
    if success_count > 0:
        print(f"\nüéµ FICHIERS G√âN√âR√âS DISPONIBLES:")
        output_dir = Path("test_output")
        validation_files = sorted(output_dir.glob("validation_complexe_*.wav"))
        
        for wav_file in validation_files:
            try:
                with open(wav_file, 'rb') as f:
                    data = f.read()
                
                if is_valid_wav(data):
                    wav_info = get_wav_info(data)
                    duration = wav_info.get('duration_ms', 0) if 'error' not in wav_info else 0
                    size_mb = len(data) / 1024 / 1024
                    
                    print(f"‚úÖ {wav_file.name:40} | {duration/1000:5.1f}s | {size_mb:6.2f}MB")
                else:
                    print(f"‚ùå {wav_file.name:40} | FORMAT INVALIDE")
                    
            except Exception as e:
                print(f"‚ùå {wav_file.name:40} | ERREUR: {e}")
    
    # Nettoyage
    await manager.cleanup()
    
    return success_count, error_count

if __name__ == "__main__":
    async def main():
        print("üöÄ D√âMARRAGE G√âN√âRATION TESTS VALIDATION COMPLEXES")
        
        success, errors = await generer_tests_validation_complexes()
        
        print(f"\nüèÅ G√âN√âRATION TERMIN√âE")
        print("=" * 70)
        
        if success > 0:
            print(f"‚úÖ {success} fichiers g√©n√©r√©s avec succ√®s!")
            print("üéµ Vous pouvez maintenant √©couter les tests de validation complexes!")
            print("üìÅ Fichiers disponibles dans: test_output/validation_complexe_*.wav")
        
        if errors > 0:
            print(f"‚ö†Ô∏è  {errors} erreurs d√©tect√©es")
        
        print("\nüéØ FICHIERS RECOMMAND√âS POUR √âCOUTE:")
        print("1. validation_complexe_complet.wav (texte complet)")
        print("2. validation_complexe_partie1_*.wav (mots simples ‚Üí techniques)")
        print("3. validation_complexe_partie2_*.wav (nombres ‚Üí phrase complexe)")
    
    asyncio.run(main()) 