#!/usr/bin/env python3
"""
Validation TTS SuperWhisper V6 - Version Simplifi√©e
==================================================
‚Ä¢ Test TTS avec approche directe
‚Ä¢ √âvite les imports complexes
‚Ä¢ Configuration RTX 3090 obligatoire
‚Ä¢ Validation audio basique

Ex√©cution :
```
python tests/test_tts_validation_simple.py
```
"""

from __future__ import annotations

import os
import sys
import time
import subprocess
from pathlib import Path
from typing import Any, Dict

import numpy as np
import sounddevice as sd

# =============================================================================
# üö® CONFIGURATION CRITIQUE GPU - RTX 3090 UNIQUEMENT 
# =============================================================================
os.environ['CUDA_VISIBLE_DEVICES'] = '1'        # RTX 3090 24GB EXCLUSIVEMENT
os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'  # Ordre stable des GPU
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:1024'  # Optimisation m√©moire

print("üéÆ GPU Configuration: RTX 3090 (CUDA:1) forc√©e")
print(f"üîí CUDA_VISIBLE_DEVICES: {os.environ.get('CUDA_VISIBLE_DEVICES')}")

def validate_rtx3090_configuration():
    """Validation obligatoire de la configuration RTX 3090"""
    try:
        import torch
        if not torch.cuda.is_available():
            raise RuntimeError("üö´ CUDA non disponible - RTX 3090 requise")
        
        cuda_devices = os.environ.get('CUDA_VISIBLE_DEVICES', '')
        if cuda_devices != '1':
            raise RuntimeError(f"üö´ CUDA_VISIBLE_DEVICES='{cuda_devices}' incorrect - doit √™tre '1'")
        
        gpu_memory = torch.cuda.get_device_properties(0).total_memory / 1024**3
        if gpu_memory < 20:  # RTX 3090 = ~24GB
            raise RuntimeError(f"üö´ GPU ({gpu_memory:.1f}GB) trop petite - RTX 3090 requise")
        
        print(f"‚úÖ RTX 3090 valid√©e: {torch.cuda.get_device_name(0)} ({gpu_memory:.1f}GB)")
        return True, torch.cuda.get_device_name(0), gpu_memory
    except Exception as e:
        print(f"‚ö†Ô∏è Validation GPU √©chou√©e: {e}")
        return False, str(e), 0

def test_tts_with_piper():
    """Test TTS avec Piper directement (sans UnifiedTTSManager)"""
    
    print("\n‚ñà‚ñà‚ñà‚ñà  SuperWhisper V6 ‚Äì Test TTS Simplifi√©  ‚ñà‚ñà‚ñà‚ñà")
    
    # =========================================================================
    # √âTAPE 1: VALIDATION GPU RTX 3090
    # =========================================================================
    print("\nüîß √âTAPE 1: VALIDATION GPU RTX 3090")
    gpu_ok, gpu_name, gpu_memory = validate_rtx3090_configuration()
    
    if not gpu_ok:
        print("‚ùå Validation GPU √©chou√©e - Arr√™t du test")
        return False

    # =========================================================================
    # √âTAPE 2: V√âRIFICATION PIPER
    # =========================================================================
    print("\nüîß √âTAPE 2: V√âRIFICATION PIPER TTS")
    
    # Chercher l'ex√©cutable Piper
    piper_paths = [
        "piper/piper.exe",
        "TTS/piper/piper.exe", 
        "C:/Dev/SuperWhisper_V6/piper/piper.exe",
        "piper.exe"
    ]
    
    piper_exe = None
    for path in piper_paths:
        if Path(path).exists():
            piper_exe = path
            break
    
    if not piper_exe:
        print("‚ùå Ex√©cutable Piper non trouv√©")
        print("üìÅ Chemins test√©s:")
        for path in piper_paths:
            print(f"   - {path}")
        return False
    
    print(f"‚úÖ Piper trouv√©: {piper_exe}")
    
    # Chercher mod√®le Piper
    model_paths = [
        "TTS/models/fr_FR-siwis-medium.onnx",
        "models/fr_FR-siwis-medium.onnx",
        "piper/models/fr_FR-siwis-medium.onnx"
    ]
    
    model_path = None
    for path in model_paths:
        if Path(path).exists():
            model_path = path
            break
    
    if not model_path:
        print("‚ùå Mod√®le Piper non trouv√©")
        print("üìÅ Chemins test√©s:")
        for path in model_paths:
            print(f"   - {path}")
        return False
    
    print(f"‚úÖ Mod√®le trouv√©: {model_path}")

    # =========================================================================
    # √âTAPE 3: TEST SYNTH√àSE VOCALE DIRECTE
    # =========================================================================
    print("\nüîä √âTAPE 3: TEST SYNTH√àSE VOCALE DIRECTE")
    
    test_text = "Bonjour ! Je suis SuperWhisper V6, votre assistant vocal."
    print(f"üìù Texte √† synth√©tiser: '{test_text}'")
    
    try:
        print("üîÑ Synth√®se avec Piper...")
        start_time = time.perf_counter()
        
        # Commande Piper directe
        cmd = [
            piper_exe,
            "--model", model_path,
            "--output_raw"
        ]
        
        # Ex√©cution Piper
        result = subprocess.run(
            cmd,
            input=test_text.encode('utf-8'),
            capture_output=True,
            timeout=10
        )
        
        end_time = time.perf_counter()
        latency_ms = (end_time - start_time) * 1000
        
        if result.returncode != 0:
            print(f"‚ùå Erreur Piper: {result.stderr.decode()}")
            return False
        
        audio_raw = result.stdout
        print(f"‚úÖ Synth√®se r√©ussie: {len(audio_raw):,} bytes")
        print(f"‚ö° Latence TTS: {latency_ms:.1f}ms")
        
    except subprocess.TimeoutExpired:
        print("‚ùå Timeout Piper (>10s)")
        return False
    except Exception as e:
        print(f"‚ùå Erreur synth√®se: {e}")
        return False

    # =========================================================================
    # √âTAPE 4: LECTURE AUDIO SIMUL√âE
    # =========================================================================
    print("\nüîà √âTAPE 4: VALIDATION AUDIO")
    
    try:
        # Simulation lecture audio (Piper g√©n√®re du PCM brut)
        sample_rate = 22050  # Piper par d√©faut
        duration_s = len(audio_raw) / (sample_rate * 2)  # 16-bit = 2 bytes
        
        print(f"üéµ Sample rate: {sample_rate}Hz")
        print(f"‚è±Ô∏è Dur√©e audio: {duration_s:.1f}s")
        print(f"üìä Taille: {len(audio_raw):,} bytes")
        
        # Conversion pour lecture (simulation)
        if len(audio_raw) > 0:
            # Convertir PCM 16-bit en numpy
            audio_np = np.frombuffer(audio_raw, dtype=np.int16)
            
            print("üîä Lecture audio simul√©e - √âcoutez attentivement...")
            sd.play(audio_np, samplerate=sample_rate)
            sd.wait()
            
            print("‚úÖ Audio jou√© avec succ√®s")
        else:
            print("‚ö†Ô∏è Audio vide g√©n√©r√©")
            return False
        
    except Exception as e:
        print(f"‚ùå Erreur lecture audio: {e}")
        return False

    # =========================================================================
    # VALIDATION HUMAINE
    # =========================================================================
    print("\n" + "="*60)
    print("üßë VALIDATION HUMAINE TTS")
    print("="*60)
    print(f"üìù Texte synth√©tis√©: '{test_text}'")
    print(f"‚ö° Latence TTS: {latency_ms:.1f}ms")
    print(f"üéµ Dur√©e audio: {duration_s:.1f}s")
    print(f"üéÆ GPU utilis√©e: {gpu_name}")
    print(f"üîß Outil: Piper TTS direct")
    
    # Questions validation
    questions = [
        "Avez-vous entendu l'audio TTS ?",
        "La voix est-elle claire et compr√©hensible ?", 
        "La latence TTS est-elle acceptable ?",
        "Le TTS fonctionne-t-il correctement ?"
    ]
    
    all_ok = True
    for question in questions:
        response = input(f"‚ùì {question} (y/n): ").strip().lower()
        if not response.startswith("y"):
            all_ok = False
    
    # Verdict final
    print("\n" + "="*60)
    if all_ok:
        print("‚úÖ VALIDATION TTS : SUCC√àS")
        print("üéä TTS SuperWhisper V6 VALID√â !")
        print("="*60)
        return True
    else:
        print("‚ùå VALIDATION TTS : √âCHEC")
        print("üîß TTS n√©cessite des corrections")
        print("="*60)
        return False

if __name__ == "__main__":
    try:
        success = test_tts_with_piper()
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"\n‚ùå ERREUR CRITIQUE: {e}")
        sys.exit(1) 