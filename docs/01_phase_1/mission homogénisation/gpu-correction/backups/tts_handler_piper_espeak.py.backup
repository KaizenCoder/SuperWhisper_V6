# TTS/tts_handler_piper_espeak.py
import os
import json
import numpy as np
import sounddevice as sd
import soundfile as sf
import onnxruntime
import subprocess
import tempfile

# Configuration RTX 3090 OBLIGATOIRE
os.environ['CUDA_VISIBLE_DEVICES'] = '1'  # RTX 3090 24GB
os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'

class TTSHandlerPiperEspeak:
    def __init__(self, config):
        self.config = config
        
        # Chemins modÃ¨le
        self.model_path = config.get('model_path', 'D:\\TTS_Voices\\piper\\fr_FR-siwis-medium.onnx')
        self.config_path = config.get('config_path', 'D:\\TTS_Voices\\piper\\fr_FR-siwis-medium.onnx.json')
        self.use_gpu = config.get('use_gpu', True)
        self.sample_rate = config.get('sample_rate', 22050)
        
        # VÃ©rifier espeak
        self._check_espeak()
        
        # Charger la configuration du modÃ¨le
        self._load_model_config()
        
        # Charger le modÃ¨le ONNX
        self._load_model()
        
    def _check_espeak(self):
        """VÃ©rifier que espeak-ng est disponible"""
        try:
            result = subprocess.run(['espeak', '--version'], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                print(f"âœ… Espeak dÃ©tectÃ©: {result.stdout.strip()}")
                self.espeak_available = True
            else:
                print(f"âš ï¸ Espeak non disponible (code: {result.returncode})")
                self.espeak_available = False
        except Exception as e:
            print(f"âš ï¸ Espeak non disponible: {e}")
            self.espeak_available = False
            
    def _load_model_config(self):
        """Charger la configuration JSON du modÃ¨le Piper"""
        print(f"ğŸ“„ Chargement config espeak franÃ§aise: {self.config_path}")
        
        with open(self.config_path, 'r', encoding='utf-8') as f:
            self.model_config = json.load(f)
            
        # Extraire les paramÃ¨tres
        audio_config = self.model_config.get('audio', {})
        self.sample_rate = audio_config.get('sample_rate', 22050)
        
        inference_config = self.model_config.get('inference', {})
        self.noise_scale = inference_config.get('noise_scale', 0.667)
        self.length_scale = inference_config.get('length_scale', 1.0)
        self.noise_w = inference_config.get('noise_w', 0.8)
        
        # Mapping phonÃ¨me â†’ ID
        self.phoneme_id_map = self.model_config.get('phoneme_id_map', {})
        
        print(f"âœ… Config espeak franÃ§aise chargÃ©e: {len(self.phoneme_id_map)} phonÃ¨mes")
        print(f"   Sample rate: {self.sample_rate}Hz")
        print(f"   ParamÃ¨tres: noise={self.noise_scale}, length={self.length_scale}, noise_w={self.noise_w}")
        
    def _load_model(self):
        """Charger le modÃ¨le ONNX avec RTX 3090"""
        print(f"ğŸ”„ Chargement modÃ¨le espeak franÃ§ais RTX 3090: {self.model_path}")
        
        # Ajout des DLLs CUDA au PATH
        torch_lib_path = os.path.join(os.getcwd(), 'venv_piper312', 'Lib', 'site-packages', 'torch', 'lib')
        if os.path.exists(torch_lib_path):
            current_path = os.environ.get('PATH', '')
            if torch_lib_path not in current_path:
                os.environ['PATH'] = current_path + os.pathsep + torch_lib_path
        
        # Providers optimisÃ©s RTX 3090
        providers = []
        if self.use_gpu:
            providers.append(('CUDAExecutionProvider', {
                'device_id': 0,
                'arena_extend_strategy': 'kNextPowerOfTwo',
                'gpu_mem_limit': 8 * 1024 * 1024 * 1024,  # 8GB
                'cudnn_conv_algo_search': 'EXHAUSTIVE',
                'do_copy_in_default_stream': True,
            }))
        providers.append('CPUExecutionProvider')
        
        # CrÃ©er session ONNX
        self.session = onnxruntime.InferenceSession(self.model_path, providers=providers)
        
        # VÃ©rifier providers
        current_providers = self.session.get_providers()
        print(f"ğŸš€ Providers: {current_providers}")
        
        if 'CUDAExecutionProvider' in current_providers:
            print("âœ… RTX 3090 CUDA activÃ©")
        else:
            print("âš ï¸ Fallback CPU")
            
        # MÃ©tadonnÃ©es modÃ¨le
        self.model_inputs = [inp.name for inp in self.session.get_inputs()]
        self.model_outputs = [out.name for out in self.session.get_outputs()]
        
    def text_to_phonemes_espeak(self, text):
        """Conversion texte â†’ phonÃ¨mes franÃ§ais via espeak-ng AUTHENTIQUE"""
        
        if not self.espeak_available:
            print("âš ï¸ Espeak non disponible, utilisation fallback")
            return self._fallback_phonemes(text)
        
        try:
            # Appel espeak-ng pour franÃ§ais
            result = subprocess.run([
                'espeak', '-v', 'fr',  # Voix franÃ§aise
                '--ipa',              # Sortie IPA
                '-q',                 # Silencieux
                text
            ], capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                ipa_output = result.stdout.strip()
                print(f"   ğŸ‡«ğŸ‡· Espeak IPA: {ipa_output}")
                
                # Conversion IPA â†’ IDs phonÃ¨mes
                phoneme_ids = []
                
                # Marqueur dÃ©but
                if "^" in self.phoneme_id_map:
                    phoneme_ids.extend(self.phoneme_id_map["^"])
                
                # Traiter chaque caractÃ¨re IPA
                for char in ipa_output:
                    if char in self.phoneme_id_map:
                        phoneme_ids.extend(self.phoneme_id_map[char])
                    elif char == ' ':
                        if ' ' in self.phoneme_id_map:
                            phoneme_ids.extend(self.phoneme_id_map[' '])
                
                # Marqueur fin
                if "$" in self.phoneme_id_map:
                    phoneme_ids.extend(self.phoneme_id_map["$"])
                
                return phoneme_ids
                
            else:
                print(f"âš ï¸ Espeak erreur: {result.stderr}")
                return self._fallback_phonemes(text)
                
        except Exception as e:
            print(f"âš ï¸ Espeak exception: {e}")
            return self._fallback_phonemes(text)
            
    def _fallback_phonemes(self, text):
        """PhonÃ©misation fallback simplifiÃ©e"""
        phoneme_ids = []
        
        # Marqueur dÃ©but
        if "^" in self.phoneme_id_map:
            phoneme_ids.extend(self.phoneme_id_map["^"])
            
        # Conversion basique
        for char in text.lower():
            if char in self.phoneme_id_map:
                phoneme_ids.extend(self.phoneme_id_map[char])
            elif ' ' in self.phoneme_id_map:
                phoneme_ids.extend(self.phoneme_id_map[' '])
                
        # Marqueur fin
        if "$" in self.phoneme_id_map:
            phoneme_ids.extend(self.phoneme_id_map["$"])
            
        return phoneme_ids
        
    def synthesize(self, text):
        """SynthÃ¨se vocale franÃ§aise espeak RTX 3090"""
        print(f"ğŸ‡«ğŸ‡· SynthÃ¨se vocale ESPEAK FRANÃ‡AISE (RTX 3090)")
        print(f"   Texte: '{text}'")
        
        try:
            # 1. Conversion texte â†’ phonÃ¨mes espeak franÃ§ais
            phoneme_ids = self.text_to_phonemes_espeak(text)
            print(f"   ğŸ“ PhonÃ¨mes espeak franÃ§ais: {len(phoneme_ids)} IDs - {phoneme_ids[:10]}...")
            
            # 2. PrÃ©paration inputs ONNX
            input_ids = np.array([phoneme_ids], dtype=np.int64)
            input_lengths = np.array([len(phoneme_ids)], dtype=np.int64)
            scales = np.array([self.noise_scale, self.length_scale, self.noise_w], dtype=np.float32)
            
            # 3. InfÃ©rence RTX 3090
            onnx_inputs = {
                'input': input_ids,
                'input_lengths': input_lengths,
                'scales': scales
            }
            
            outputs = self.session.run(None, onnx_inputs)
            audio_data = outputs[0]
            
            # 4. Post-processing
            audio_data = np.squeeze(audio_data)
            
            print(f"   ğŸµ Audio espeak franÃ§ais gÃ©nÃ©rÃ©: {audio_data.shape} Ã©chantillons")
            print(f"   ğŸ” Range audio: [{audio_data.min():.3f}, {audio_data.max():.3f}]")
            
            # VÃ©rifier qualitÃ© audio
            amplitude = max(abs(audio_data.min()), abs(audio_data.max()))
            if amplitude > 0.1:
                print(f"   âœ… Audio espeak franÃ§ais valide (amplitude: {amplitude:.3f})")
            else:
                print(f"   âš ï¸ Audio espeak franÃ§ais faible (amplitude: {amplitude:.3f})")
            
            # Conversion pour lecture
            audio_int16 = (audio_data * 32767).clip(-32767, 32767).astype(np.int16)
            
            return audio_int16
            
        except Exception as e:
            print(f"âŒ Erreur synthÃ¨se espeak franÃ§aise: {e}")
            import traceback
            traceback.print_exc()
            return np.array([], dtype=np.int16)
    
    def speak(self, text):
        """SynthÃ¨se et lecture audio espeak franÃ§ais RTX 3090"""
        audio_data = self.synthesize(text)
        
        if len(audio_data) > 0:
            print(f"   ğŸ”Š Lecture audio espeak franÃ§ais...")
            sd.play(audio_data, samplerate=self.sample_rate)
            sd.wait()
            print(f"   âœ… Lecture espeak franÃ§aise terminÃ©e")
        else:
            print(f"   âŒ Pas d'audio espeak franÃ§ais Ã  lire")
            
        return audio_data 