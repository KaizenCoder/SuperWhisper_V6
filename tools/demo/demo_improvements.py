#!/usr/bin/env python3
"""
Script de Validation Compl√®te - Luxa SuperWhisper V6
===================================================

D√©monstrateur des am√©liorations de s√©curit√©, robustesse et performance.
Ce script illustre toutes les corrections apport√©es suite au peer review.

üö® CONFIGURATION GPU: RTX 3090 (CUDA:1) OBLIGATOIRE
"""

import os
import sys
import pathlib

# =============================================================================
# üöÄ PORTABILIT√â AUTOMATIQUE - EX√âCUTABLE DEPUIS N'IMPORTE O√ô
# =============================================================================
def _setup_portable_environment():
    """Configure l'environnement pour ex√©cution portable"""
    # D√©terminer le r√©pertoire racine du projet
    current_file = pathlib.Path(__file__).resolve()
    
    # Chercher le r√©pertoire racine (contient .git ou marqueurs projet)
    project_root = current_file
    for parent in current_file.parents:
        if any((parent / marker).exists() for marker in ['.git', 'pyproject.toml', 'requirements.txt', '.taskmaster']):
            project_root = parent
            break
    
    # Ajouter le projet root au Python path
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))
    
    # Changer le working directory vers project root
    os.chdir(project_root)
    
    # Configuration GPU RTX 3090 obligatoire
    os.environ['CUDA_VISIBLE_DEVICES'] = '1'        # RTX 3090 24GB EXCLUSIVEMENT
    os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'  # Ordre stable des GPU
    
    print(f"üéÆ GPU Configuration: RTX 3090 (CUDA:1) forc√©e")
    print(f"üìÅ Project Root: {project_root}")
    print(f"üíª Working Directory: {os.getcwd()}")
    
    return project_root

# Initialiser l'environnement portable
_PROJECT_ROOT = _setup_portable_environment()

# Maintenant imports normaux...

import asyncio
import numpy as np
import time
import json
import logging
from pathlib import Path
import sys

# Imports des modules am√©lior√©s
sys.path.append(str(Path(__file__).parent))

from config.security_config import SecurityConfig
from utils.error_handler import RobustErrorHandler
from Orchestrator.master_handler_robust import RobustMasterHandler

# Configuration logging color√©
class ColoredFormatter(logging.Formatter):
    """Formatter avec couleurs pour d√©monstration"""
    
    COLORS = {
        'DEBUG': '\033[36m',    # Cyan
        'INFO': '\033[32m',     # Vert
        'WARNING': '\033[33m',  # Jaune
        'ERROR': '\033[31m',    # Rouge
        'CRITICAL': '\033[35m', # Magenta
    }
    RESET = '\033[0m'
    
    def format(self, record):
        log_color = self.COLORS.get(record.levelname, self.RESET)
        record.levelname = f"{log_color}{record.levelname}{self.RESET}"
        return super().format(record)

# Configuration logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)

# Appliquer formatter color√©
for handler in logging.root.handlers:
    handler.setFormatter(ColoredFormatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))

logger = logging.getLogger(__name__)

class LuxaSecurityDemo:
    """D√©monstration des am√©liorations de s√©curit√©"""
    
    def __init__(self):
        self.security_config = SecurityConfig(config_dir="demo_config")
        
    def demo_api_key_management(self):
        """D√©montre la gestion s√©curis√©e des cl√©s API"""
        
        print("\nüîê === D√âMONSTRATION S√âCURIT√â - GESTION CL√âS API ===")
        
        # 1. G√©n√©ration cl√© API s√©curis√©e
        print("\n1Ô∏è‚É£ G√©n√©ration cl√© API s√©curis√©e:")
        api_key = self.security_config.generate_api_key("demo_user")
        print(f"   ‚úÖ Cl√© g√©n√©r√©e: {api_key[:20]}... (truncated)")
        print(f"   üîí Hash stock√© de fa√ßon s√©curis√©e")
        
        # 2. Validation cl√© API
        print("\n2Ô∏è‚É£ Validation cl√© API:")
        user = self.security_config.validate_api_key(api_key)
        print(f"   ‚úÖ Validation r√©ussie pour: {user}")
        
        # Test cl√© invalide
        invalid_result = self.security_config.validate_api_key("cl√©_invalide")
        print(f"   ‚ùå Cl√© invalide rejet√©e: {invalid_result}")
        
        # 3. G√©n√©ration et validation JWT
        print("\n3Ô∏è‚É£ Gestion JWT:")
        token = self.security_config.generate_jwt_token({
            "username": user,
            "permissions": ["audio_processing", "model_access"],
            "role": "user"
        })
        print(f"   ‚úÖ Token JWT g√©n√©r√© (longueur: {len(token)} chars)")
        
        # Validation JWT
        decoded = self.security_config.validate_jwt_token(token)
        print(f"   ‚úÖ Token valid√©: {decoded['username']} - {decoded['permissions']}")
        
        return api_key, token
    
    def demo_input_validation(self):
        """D√©montre la validation s√©curis√©e des entr√©es"""
        
        print("\nüõ°Ô∏è === D√âMONSTRATION VALIDATION ENTR√âES ===")
        
        # 1. Audio valide
        print("\n1Ô∏è‚É£ Validation audio valide:")
        valid_audio = self._create_wav_audio(16000)  # 1 seconde
        validation = self.security_config.validate_audio_input(valid_audio, "test.wav")
        print(f"   ‚úÖ Audio valide: {validation['valid']}")
        print(f"   üìä Taille: {len(valid_audio)/1024:.1f} KB")
        
        # 2. Audio trop volumineux
        print("\n2Ô∏è‚É£ Rejet audio trop volumineux:")
        large_audio = b"x" * (15 * 1024 * 1024)  # 15MB
        validation = self.security_config.validate_audio_input(large_audio, "large.wav")
        print(f"   ‚ùå Audio rejet√©: {validation['valid']}")
        print(f"   üö´ Erreur: {validation['errors'][0]}")
        
        # 3. Format non support√©
        print("\n3Ô∏è‚É£ Rejet format non support√©:")
        validation = self.security_config.validate_audio_input(b"test", "malware.exe")
        print(f"   ‚ùå Format rejet√©: {validation['valid']}")
        print(f"   üö´ Erreur: {validation['errors'][0]}")
        
        # 4. D√©tection contenu suspect
        print("\n4Ô∏è‚É£ D√©tection contenu suspect:")
        suspicious_data = b"MZ\x90\x00" + b"fake_audio_data" * 100
        validation = self.security_config.validate_audio_input(suspicious_data, "suspicious.wav")
        print(f"   ‚ùå Contenu suspect d√©tect√©: {not validation['valid']}")
        
        # 5. Nettoyage texte
        print("\n5Ô∏è‚É£ Nettoyage entr√©es texte:")
        dirty_text = "Hello\x00\x07world\x1f avec caract√®res\x0c de contr√¥le"
        clean_text = self.security_config.sanitize_text_input(dirty_text)
        print(f"   üìù Texte original: {repr(dirty_text)}")
        print(f"   ‚ú® Texte nettoy√©: {repr(clean_text)}")
    
    def _create_wav_audio(self, samples: int) -> bytes:
        """Cr√©e un fichier WAV valide pour tests"""
        # Header WAV minimal
        header = (
            b'RIFF' + (samples * 2 + 36).to_bytes(4, 'little') +
            b'WAVEfmt ' + (16).to_bytes(4, 'little') +
            (1).to_bytes(2, 'little') + (1).to_bytes(2, 'little') +
            (16000).to_bytes(4, 'little') + (32000).to_bytes(4, 'little') +
            (2).to_bytes(2, 'little') + (16).to_bytes(2, 'little') +
            b'data' + (samples * 2).to_bytes(4, 'little')
        )
        
        # Donn√©es audio (silence)
        audio_data = np.zeros(samples, dtype=np.int16).tobytes()
        
        return header + audio_data

class LuxaRobustnessDemo:
    """D√©monstration des am√©liorations de robustesse"""
    
    def __init__(self):
        self.error_handler = RobustErrorHandler()
        
    async def demo_circuit_breaker(self):
        """D√©montre le fonctionnement des circuit breakers"""
        
        print("\n‚ö° === D√âMONSTRATION CIRCUIT BREAKERS ===")
        
        # Enregistrer un composant de test
        self.error_handler.register_component("demo_service", failure_threshold=3, max_retries=2)
        
        # Simuler service d√©faillant
        failure_count = 0
        
        async def unreliable_service():
            nonlocal failure_count
            failure_count += 1
            
            if failure_count <= 5:  # 5 premi√®res tentatives √©chouent
                raise Exception(f"Service failure #{failure_count}")
            
            return f"Success after {failure_count} attempts"
        
        print("\n1Ô∏è‚É£ Test avec service d√©faillant:")
        
        # Premi√®re s√©rie d'appels - doit ouvrir le circuit
        for i in range(6):
            try:
                result = await self.error_handler.execute_safe("demo_service", unreliable_service)
                print(f"   ‚úÖ Tentative {i+1}: {result}")
            except Exception as e:
                print(f"   ‚ùå Tentative {i+1}: {str(e)}")
            
            # Afficher √©tat du circuit
            circuit = self.error_handler.circuit_breakers["demo_service"]
            print(f"      üîÑ √âtat circuit: {circuit.state.value} (erreurs: {circuit.metrics.consecutive_errors})")
            
            if circuit.state.value == "open":
                print(f"      üö® Circuit ouvert apr√®s {circuit.metrics.consecutive_errors} erreurs!")
                break
            
            await asyncio.sleep(0.1)
        
        print("\n2Ô∏è‚É£ √âtat du circuit breaker:")
        status = self.error_handler.get_health_status()
        print(f"   üìä Composants sains: {status['healthy_components']}/{status['total_components']}")
        print(f"   üìà Taux d'erreur global: {status['global_metrics']['error_rate']:.2%}")
    
    async def demo_retry_mechanism(self):
        """D√©montre le m√©canisme de retry"""
        
        print("\nüîÑ === D√âMONSTRATION RETRY ===")
        
        # Service qui r√©ussit au 3√®me essai
        attempt_count = 0
        
        async def flaky_service():
            nonlocal attempt_count
            attempt_count += 1
            
            if attempt_count < 3:
                raise Exception(f"Temporary failure (attempt {attempt_count})")
            
            return f"Success on attempt {attempt_count}!"
        
        print("\n1Ô∏è‚É£ Service avec √©checs temporaires:")
        
        try:
            result = await self.error_handler.execute_safe("demo_service", flaky_service)
            print(f"   ‚úÖ R√©sultat final: {result}")
            print(f"   üîÑ Nombre total d'essais: {attempt_count}")
        except Exception as e:
            print(f"   ‚ùå √âchec d√©finitif: {e}")

class LuxaPerformanceDemo:
    """D√©monstration des am√©liorations de performance"""
    
    async def demo_pipeline_performance(self):
        """D√©montre les performances du pipeline am√©lior√©"""
        
        print("\nüöÄ === D√âMONSTRATION PERFORMANCE ===")
        
        # Initialiser le handler robuste
        handler = RobustMasterHandler()
        await handler.initialize()
        
        print("\n1Ô∏è‚É£ Test latence avec diff√©rents types d'audio:")
        
        audio_types = {
            "silence": np.zeros(16000, dtype=np.float32),
            "speech_sim": self._generate_speech_signal(16000),
            "noise": np.random.normal(0, 0.1, 16000).astype(np.float32)
        }
        
        for audio_type, audio_data in audio_types.items():
            latencies = []
            
            # 5 mesures par type
            for i in range(5):
                start_time = time.perf_counter()
                
                result = await handler.process_audio_secure(
                    audio_chunk=audio_data,
                    jwt_token=handler.security_config.generate_jwt_token({"username": "perf_demo"})
                )
                
                end_time = time.perf_counter()
                latency_ms = (end_time - start_time) * 1000
                latencies.append(latency_ms)
            
            avg_latency = sum(latencies) / len(latencies)
            min_latency = min(latencies)
            max_latency = max(latencies)
            
            print(f"   üìä {audio_type:12s}: Œº={avg_latency:5.1f}ms min={min_latency:5.1f}ms max={max_latency:5.1f}ms")
            
            # V√©rifier objectifs
            if audio_type == "silence":
                assert avg_latency < 100, f"Silence trop lent: {avg_latency:.1f}ms"
            else:
                assert avg_latency < 3000, f"{audio_type} trop lent: {avg_latency:.1f}ms"
        
        print("\n2Ô∏è‚É£ Test charge concurrente:")
        
        async def concurrent_request(req_id: int):
            """Requ√™te concurrente"""
            audio = self._generate_speech_signal(8000)  # Audio court
            
            start = time.perf_counter()
            result = await handler.process_audio_secure(
                audio_chunk=audio,
                jwt_token=handler.security_config.generate_jwt_token({"username": f"concurrent_{req_id}"})
            )
            end = time.perf_counter()
            
            return {
                "req_id": req_id,
                "latency_ms": (end - start) * 1000,
                "success": result["success"]
            }
        
        # Test avec 5 requ√™tes concurrentes
        concurrent_tasks = [concurrent_request(i) for i in range(5)]
        results = await asyncio.gather(*concurrent_tasks)
        
        successful = [r for r in results if r["success"]]
        success_rate = len(successful) / len(results)
        
        if successful:
            avg_concurrent_latency = sum(r["latency_ms"] for r in successful) / len(successful)
            print(f"   ‚ö° Requ√™tes concurrentes: {len(successful)}/{len(results)} r√©ussies")
            print(f"   üìä Latence moyenne: {avg_concurrent_latency:.1f}ms")
            print(f"   üéØ Taux de succ√®s: {success_rate:.1%}")
        
        print("\n3Ô∏è‚É£ √âtat de sant√© syst√®me:")
        health = handler.get_health_status()
        print(f"   üè• Statut: {health['status']}")
        print(f"   üìà Requ√™tes trait√©es: {health['performance']['requests_processed']}")
        print(f"   ‚ö° Latence moyenne: {health['performance']['avg_latency_ms']:.1f}ms")
        print(f"   ‚úÖ Taux de succ√®s: {health['performance']['success_rate']:.1%}")
    
    def _generate_speech_signal(self, length: int) -> np.ndarray:
        """G√©n√®re un signal similaire √† la parole"""
        t = np.linspace(0, length/16000, length)
        
        # Formants typiques
        f1 = 800 + 200 * np.sin(2 * np.pi * 3 * t)
        f2 = 1200 + 300 * np.sin(2 * np.pi * 2 * t)
        
        signal = (
            0.4 * np.sin(2 * np.pi * f1 * t) +
            0.3 * np.sin(2 * np.pi * f2 * t)
        )
        
        envelope = 0.5 * (1 + np.sin(2 * np.pi * 1.5 * t))
        
        return (signal * envelope * 0.7).astype(np.float32)

class LuxaIntegrationDemo:
    """D√©monstration d'int√©gration compl√®te"""
    
    async def demo_complete_workflow(self):
        """D√©montre le workflow complet s√©curis√©"""
        
        print("\nüéØ === D√âMONSTRATION WORKFLOW COMPLET ===")
        
        # 1. Configuration s√©curit√©
        print("\n1Ô∏è‚É£ Configuration s√©curit√©:")
        security = SecurityConfig(config_dir="integration_demo")
        api_key = security.generate_api_key("integration_user")
        print(f"   üîë Cl√© API g√©n√©r√©e pour integration_user")
        
        # 2. Initialisation handler robuste
        print("\n2Ô∏è‚É£ Initialisation handler robuste:")
        handler = RobustMasterHandler()
        await handler.initialize()
        print(f"   ‚úÖ Handler initialis√© avec protection compl√®te")
        
        # 3. Validation et traitement audio s√©curis√©
        print("\n3Ô∏è‚É£ Traitement audio s√©curis√©:")
        
        # Cr√©er audio de test
        audio_data = np.random.normal(0, 0.1, 16000).astype(np.float32)
        
        # Traitement avec authentification
        result = await handler.process_audio_secure(
            audio_chunk=audio_data,
            api_key=api_key,
            filename="integration_test.wav"
        )
        
        print(f"   ‚úÖ Traitement r√©ussi: {result['success']}")
        print(f"   üîê Utilisateur authentifi√©: {result['security']['user']}")
        print(f"   üõ°Ô∏è M√©thode auth: {result['security']['auth_method']}")
        print(f"   üìä Latence: {result['latency_ms']:.1f}ms")
        print(f"   üé§ Composants utilis√©s: {list(result['components_used'].keys())}")
        
        # 4. M√©triques et monitoring
        print("\n4Ô∏è‚É£ M√©triques et monitoring:")
        health = handler.get_health_status()
        
        print(f"   üìä Requ√™tes totales: {health['performance']['requests_processed']}")
        print(f"   ‚ö° Latence moyenne: {health['performance']['avg_latency_ms']:.1f}ms")
        print(f"   üîí Circuits breakers: {len(health['security']['circuit_breakers']['components'])} actifs")
        
        # 5. Export m√©triques Prometheus
        print("\n5Ô∏è‚É£ Export m√©triques Prometheus:")
        prometheus_metrics = handler.error_handler.export_metrics_prometheus()
        metrics_lines = prometheus_metrics.split('\n')[:5]  # Premi√®res lignes
        for line in metrics_lines:
            if line.strip():
                print(f"   üìà {line}")
        print(f"   ... (+{len(prometheus_metrics.split()) - 5} m√©triques)")

async def main():
    """Fonction principale de d√©monstration"""
    
    print("üé®" + "="*70)
    print("üé®  LUXA SUPERWHISPER V6 - D√âMONSTRATION AM√âLIORATIONS")
    print("üé®  Suite aux recommandations du Peer Review")
    print("üé®" + "="*70)
    
    try:
        # 1. D√©monstration s√©curit√©
        security_demo = LuxaSecurityDemo()
        api_key, jwt_token = security_demo.demo_api_key_management()
        security_demo.demo_input_validation()
        
        # 2. D√©monstration robustesse
        robustness_demo = LuxaRobustnessDemo()
        await robustness_demo.demo_circuit_breaker()
        await robustness_demo.demo_retry_mechanism()
        
        # 3. D√©monstration performance
        performance_demo = LuxaPerformanceDemo()
        await performance_demo.demo_pipeline_performance()
        
        # 4. D√©monstration int√©gration
        integration_demo = LuxaIntegrationDemo()
        await integration_demo.demo_complete_workflow()
        
        print("\nüéâ" + "="*70)
        print("üéâ  D√âMONSTRATION TERMIN√âE AVEC SUCC√àS!")
        print("üéâ  Toutes les am√©liorations sont fonctionnelles:")
        print("üéâ  ‚úÖ S√©curit√© renforc√©e (auth, validation)")
        print("üéâ  ‚úÖ Robustesse am√©lior√©e (circuit breakers, retry)")
        print("üéâ  ‚úÖ Performance optimis√©e (latence, d√©bit)")
        print("üéâ  ‚úÖ Monitoring complet (m√©triques, sant√©)")
        print("üéâ" + "="*70)
        
    except Exception as e:
        logger.error(f"‚ùå Erreur durant la d√©monstration: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    # Nettoyer les dossiers de test pr√©c√©dents
    import shutil
    for demo_dir in ["demo_config", "integration_demo"]:
        if Path(demo_dir).exists():
            shutil.rmtree(demo_dir)
    
    # Lancer la d√©monstration
    asyncio.run(main())
