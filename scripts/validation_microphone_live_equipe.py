#!/usr/bin/env python3
"""
üé§ SCRIPT VALIDATION MICROPHONE LIVE - √âQUIPE VALIDATION
SuperWhisper V6 Phase 4 STT - Validation finale correction VAD

üö® CONFIGURATION GPU: RTX 3090 (CUDA:1) OBLIGATOIRE
"""

import os
import sys
import time
import json
from datetime import datetime
from pathlib import Path

# =============================================================================
# üö® CONFIGURATION CRITIQUE GPU - RTX 3090 UNIQUEMENT 
# =============================================================================
os.environ['CUDA_VISIBLE_DEVICES'] = '1'        # RTX 3090 24GB EXCLUSIVEMENT
os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'  # Ordre stable des GPU
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:1024'  # Optimisation m√©moire

print("üéÆ SuperWhisper V6 - Validation Microphone Live - Configuration GPU RTX 3090 (CUDA:1) forc√©e")
print(f"üîí CUDA_VISIBLE_DEVICES: {os.environ.get('CUDA_VISIBLE_DEVICES')}")

try:
    import torch
    import numpy as np
    import sounddevice as sd
    from STT.unified_stt_manager import UnifiedSTTManager
    print("‚úÖ Imports STT r√©ussis")
except ImportError as e:
    print(f"‚ùå Erreur import: {e}")
    print("üí° V√©rifiez l'installation des d√©pendances STT")
    sys.exit(1)

def validate_rtx3090_validation():
    """Validation syst√©matique RTX 3090 pour √©quipe validation"""
    print("\nüîç VALIDATION CONFIGURATION RTX 3090")
    print("=" * 50)
    
    if not torch.cuda.is_available():
        print("‚ùå CUDA non disponible - RTX 3090 requise")
        return False
    
    cuda_devices = os.environ.get('CUDA_VISIBLE_DEVICES', '')
    if cuda_devices != '1':
        print(f"‚ùå CUDA_VISIBLE_DEVICES='{cuda_devices}' incorrect - doit √™tre '1'")
        return False
    
    gpu_name = torch.cuda.get_device_name(0)
    if "3090" not in gpu_name:
        print(f"‚ùå GPU d√©tect√©e: {gpu_name} - RTX 3090 requise")
        return False
    
    gpu_memory = torch.cuda.get_device_properties(0).total_memory / 1024**3
    if gpu_memory < 20:
        print(f"‚ùå GPU ({gpu_memory:.1f}GB) trop petite - RTX 3090 requise")
        return False
    
    print(f"‚úÖ RTX 3090 valid√©e: {gpu_name} ({gpu_memory:.1f}GB)")
    return True

def test_microphone_setup():
    """Test setup microphone"""
    print("\nüé§ TEST SETUP MICROPHONE")
    print("=" * 30)
    
    try:
        # Lister devices audio
        devices = sd.query_devices()
        print("üìã Devices audio disponibles:")
        for i, device in enumerate(devices):
            if device['max_input_channels'] > 0:
                print(f"   {i}: {device['name']} (Input: {device['max_input_channels']} ch)")
        
        # Test enregistrement court
        print("\nüî¥ Test enregistrement 2 secondes...")
        print("   Parlez maintenant...")
        
        audio = sd.rec(int(2 * 16000), samplerate=16000, channels=1, dtype=np.float32)
        sd.wait()
        
        # V√©rifier niveau audio
        max_level = np.max(np.abs(audio))
        print(f"üìä Niveau audio max: {max_level:.3f}")
        
        if max_level < 0.01:
            print("‚ö†Ô∏è Niveau audio tr√®s faible - v√©rifiez microphone")
            return False
        elif max_level > 0.8:
            print("‚ö†Ô∏è Niveau audio tr√®s fort - risque saturation")
        else:
            print("‚úÖ Niveau audio correct")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur test microphone: {e}")
        return False

async def validation_texte_complet():
    """Validation avec texte complet fourni"""
    
    # Texte de r√©f√©rence pour validation
    TEXTE_REFERENCE = """Bonjour, je suis en train de tester le syst√®me de reconnaissance vocale SuperWhisper V6. 
Cette phrase contient plusieurs mots techniques comme reconnaissance, transcription, et validation. 
Le syst√®me doit √™tre capable de transcrire correctement tous les mots sans interruption. 
Nous testons √©galement les nombres comme 123, 456, et les dates comme le 13 juin 2025. 
Cette validation est critique pour valider la correction VAD qui a permis une am√©lioration de 492 pourcent. 
Le syst√®me utilise une RTX 3090 avec 24 gigaoctets de m√©moire vid√©o pour optimiser les performances. 
Merci de valider que cette transcription est compl√®te et pr√©cise."""
    
    print("\nüìù VALIDATION TEXTE COMPLET")
    print("=" * 40)
    print("\nüéØ TEXTE √Ä LIRE AU MICROPHONE:")
    print("-" * 40)
    print(TEXTE_REFERENCE)
    print("-" * 40)
    
    # Compter mots de r√©f√©rence
    mots_reference = len(TEXTE_REFERENCE.split())
    print(f"\nüìä Mots de r√©f√©rence: {mots_reference}")
    
    input("\nüé§ Appuyez sur Entr√©e quand vous √™tes pr√™t √† lire le texte complet...")
    
    try:
        # Initialiser STT Manager
        print("üöÄ Initialisation STT Manager...")
        stt_manager = UnifiedSTTManager()
        
        # Enregistrement long (30 secondes max)
        duree_max = 30
        print(f"\nüî¥ ENREGISTREMENT EN COURS... (max {duree_max}s)")
        print("üì¢ LISEZ LE TEXTE MAINTENANT")
        
        start_time = time.time()
        audio = sd.rec(int(duree_max * 16000), samplerate=16000, channels=1, dtype=np.float32)
        
        # Attendre fin lecture ou timeout
        print("‚èπÔ∏è Appuyez sur Entr√©e quand vous avez termin√© de lire...")
        input()
        sd.stop()
        
        duree_reelle = time.time() - start_time
        print(f"‚è±Ô∏è Dur√©e enregistrement: {duree_reelle:.1f}s")
        
        # Transcription
        print("üéÆ Transcription RTX 3090...")
        start_transcription = time.time()
        
        # Prendre seulement la partie enregistr√©e
        samples_enregistres = int(duree_reelle * 16000)
        audio_final = audio[:samples_enregistres].flatten()
        
        result = await stt_manager.transcribe(audio_final)
        
        latence_transcription = time.time() - start_transcription
        
        # Analyse r√©sultats
        texte_transcrit = result.get('text', '')
        mots_transcrits = len(texte_transcrit.split())
        couverture = (mots_transcrits / mots_reference) * 100
        
        print("\nüìä R√âSULTATS VALIDATION")
        print("=" * 30)
        print(f"üìù Texte transcrit: '{texte_transcrit}'")
        print(f"üìä Mots transcrits: {mots_transcrits}/{mots_reference}")
        print(f"üìà Couverture: {couverture:.1f}%")
        print(f"‚è±Ô∏è Latence transcription: {latence_transcription:.1f}s")
        print(f"üéØ RTF: {result.get('rtf', 'N/A')}")
        
        # Validation crit√®res
        validation_reussie = True
        criteres = []
        
        if couverture >= 95:
            criteres.append("‚úÖ Couverture excellente (‚â•95%)")
        elif couverture >= 90:
            criteres.append("üü° Couverture acceptable (‚â•90%)")
            print("‚ö†Ô∏è Couverture sous l'objectif de 95%")
        else:
            criteres.append("‚ùå Couverture insuffisante (<90%)")
            validation_reussie = False
        
        if latence_transcription <= 10:
            criteres.append("‚úÖ Latence acceptable (‚â§10s)")
        elif latence_transcription <= 15:
            criteres.append("üü° Latence limite (‚â§15s)")
        else:
            criteres.append("‚ùå Latence excessive (>15s)")
            validation_reussie = False
        
        if "interruption" not in texte_transcrit.lower() and len(texte_transcrit) > 50:
            criteres.append("‚úÖ Transcription compl√®te")
        else:
            criteres.append("‚ùå Transcription incompl√®te ou interrompue")
            validation_reussie = False
        
        print("\nüéØ CRIT√àRES VALIDATION:")
        for critere in criteres:
            print(f"   {critere}")
        
        # Validation humaine
        print("\nüë§ VALIDATION HUMAINE REQUISE")
        print("=" * 35)
        
        while True:
            precision = input("üéØ Pr√©cision transcription (excellent/bon/acceptable/insuffisant): ").lower()
            if precision in ['excellent', 'bon', 'acceptable', 'insuffisant']:
                break
            print("‚ùå R√©ponse invalide")
        
        while True:
            interruption = input("üîç Y a-t-il eu des interruptions pr√©matur√©es? (oui/non): ").lower()
            if interruption in ['oui', 'non']:
                break
            print("‚ùå R√©ponse invalide")
        
        commentaires = input("üí¨ Commentaires d√©taill√©s (optionnel): ")
        
        # D√©cision finale
        if validation_reussie and precision in ['excellent', 'bon', 'acceptable'] and interruption == 'non':
            decision_finale = "‚úÖ VALID√â"
        elif precision == 'acceptable' and interruption == 'non':
            decision_finale = "üîÑ VALID√â AVEC R√âSERVES"
        else:
            decision_finale = "‚ùå √Ä CORRIGER"
        
        # Sauvegarder rapport
        rapport = {
            "date_validation": datetime.now().isoformat(),
            "texte_reference": TEXTE_REFERENCE,
            "mots_reference": mots_reference,
            "texte_transcrit": texte_transcrit,
            "mots_transcrits": mots_transcrits,
            "couverture_pourcent": couverture,
            "latence_transcription": latence_transcription,
            "rtf": result.get('rtf'),
            "duree_enregistrement": duree_reelle,
            "precision_humaine": precision,
            "interruptions": interruption,
            "commentaires": commentaires,
            "criteres_techniques": criteres,
            "decision_finale": decision_finale,
            "validation_reussie": validation_reussie
        }
        
        # Cr√©er dossier rapport
        Path("validation_reports").mkdir(exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        fichier_rapport = f"validation_reports/validation_microphone_live_{timestamp}.json"
        
        with open(fichier_rapport, 'w', encoding='utf-8') as f:
            json.dump(rapport, f, indent=2, ensure_ascii=False)
        
        print(f"\nüíæ Rapport sauvegard√©: {fichier_rapport}")
        print(f"\nüéØ D√âCISION FINALE: {decision_finale}")
        
        return validation_reussie, rapport
        
    except Exception as e:
        print(f"‚ùå Erreur validation: {e}")
        return False, None

async def main():
    """Fonction principale validation microphone live"""
    
    print("üé§ VALIDATION MICROPHONE LIVE - SuperWhisper V6 Phase 4 STT")
    print("=" * 65)
    print("üéØ Mission: Valider correction VAD en conditions r√©elles")
    print("üìä √âtat: Correction VAD r√©ussie sur fichier (+492%)")
    print("üîç Objectif: Confirmer fonctionnement avec microphone live")
    print()
    
    # √âtape 1: Validation GPU
    if not validate_rtx3090_validation():
        print("\n‚ùå √âCHEC VALIDATION GPU - ARR√äT")
        return False
    
    # √âtape 2: Test microphone
    if not test_microphone_setup():
        print("\n‚ùå √âCHEC TEST MICROPHONE - ARR√äT")
        return False
    
    # √âtape 3: Validation texte complet
    print("\nüöÄ D√âMARRAGE VALIDATION TEXTE COMPLET")
    validation_ok, rapport = await validation_texte_complet()
    
    if validation_ok:
        print("\nüéä VALIDATION MICROPHONE LIVE R√âUSSIE!")
        print("‚úÖ La correction VAD fonctionne parfaitement en conditions r√©elles")
        print("üöÄ Phase 4 STT peut √™tre marqu√©e comme TERMIN√âE")
    else:
        print("\n‚ö†Ô∏è VALIDATION MICROPHONE LIVE PARTIELLE")
        print("üîß Des ajustements peuvent √™tre n√©cessaires")
    
    print(f"\nüìã Rapport d√©taill√© disponible dans: validation_reports/")
    return validation_ok

if __name__ == "__main__":
    import asyncio
    
    try:
        success = asyncio.run(main())
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Validation interrompue par l'utilisateur")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Erreur critique: {e}")
        sys.exit(1) 