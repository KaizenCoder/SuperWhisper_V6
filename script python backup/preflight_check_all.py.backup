#!/usr/bin/env python3
"""
ğŸš€ PRÃ‰-FLIGHT CHECK PIPELINE - ORCHESTRATEUR COMPLET
===================================================
Script orchestrateur principal des validations prÃ©-flight pour pipeline SuperWhisper V6

VALIDATIONS COMPLÃˆTES :
1. ğŸ® GPU RTX 3090 exclusive CUDA_VISIBLE_DEVICES='1'
2. ğŸ¤ Audio devices Windows (permissions + Ã©numÃ©ration)
3. ğŸ¤– Serveur LLM local (health-check + infÃ©rence)
4. ğŸ“‹ RÃ©sumÃ© final et autorisation pipeline

Usage: python PIPELINE/scripts/preflight_check_all.py
"""

import os
import sys
import subprocess
import logging
import time
from pathlib import Path
from typing import Dict, Any, List

# Configuration RTX 3090 obligatoire AVANT import torch
os.environ.setdefault('CUDA_VISIBLE_DEVICES', '1')        # RTX 3090 Bus PCI 1
os.environ.setdefault('CUDA_DEVICE_ORDER', 'PCI_BUS_ID')  # Ordre physique stable
os.environ.setdefault('PYTORCH_CUDA_ALLOC_CONF', 'max_split_size_mb:1024')

# Configuration logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger("preflight_orchestrator")

# Configuration checks
PREFLIGHT_CHECKS = [
    {
        'name': 'GPU RTX 3090 Validation',
        'script': 'assert_gpu_env.py',
        'description': 'Validation GPU RTX 3090 exclusive CUDA_VISIBLE_DEVICES=1',
        'critical': True,
        'timeout': 30
    },
    {
        'name': 'Audio Devices Validation',
        'script': 'validate_audio_devices.py', 
        'description': 'Validation permissions audio Windows + Ã©numÃ©ration devices',
        'critical': True,
        'timeout': 45
    },
    {
        'name': 'LLM Server Health-Check',
        'script': 'start_llm.py',
        'description': 'Health-check serveur LLM local + test infÃ©rence',
        'critical': True,
        'timeout': 60
    }
]

def run_preflight_check(check_config: Dict[str, Any], scripts_dir: Path) -> Dict[str, Any]:
    """
    ExÃ©cuter un check prÃ©-flight individuel
    
    Args:
        check_config: Configuration du check Ã  exÃ©cuter
        scripts_dir: RÃ©pertoire contenant les scripts
        
    Returns:
        Dict avec rÃ©sultats d'exÃ©cution
    """
    result = {
        'name': check_config['name'],
        'success': False,
        'exit_code': -1,
        'stdout': '',
        'stderr': '',
        'duration_seconds': 0,
        'error': None
    }
    
    try:
        script_path = scripts_dir / check_config['script']
        
        if not script_path.exists():
            raise FileNotFoundError(f"Script non trouvÃ©: {script_path}")
        
        logger.info(f"ğŸ” ExÃ©cution {check_config['name']}...")
        logger.info(f"   ğŸ“„ Script: {script_path}")
        logger.info(f"   ğŸ“ Description: {check_config['description']}")
        
        start_time = time.time()
        
        # ExÃ©cution avec timeout
        process = subprocess.run(
            [sys.executable, str(script_path)],
            capture_output=True,
            text=True,
            timeout=check_config['timeout'],
            cwd=scripts_dir.parent.parent  # Racine du projet
        )
        
        duration = time.time() - start_time
        result['duration_seconds'] = round(duration, 2)
        result['exit_code'] = process.returncode
        result['stdout'] = process.stdout
        result['stderr'] = process.stderr
        
        if process.returncode == 0:
            result['success'] = True
            logger.info(f"âœ… {check_config['name']} RÃ‰USSI ({duration:.1f}s)")
        else:
            logger.error(f"âŒ {check_config['name']} Ã‰CHOUÃ‰ (code {process.returncode})")
            if process.stderr:
                logger.error(f"   Erreur: {process.stderr.strip()}")
                
    except subprocess.TimeoutExpired:
        result['error'] = f"Timeout aprÃ¨s {check_config['timeout']}s"
        logger.error(f"â±ï¸ {check_config['name']}: {result['error']}")
        
    except FileNotFoundError as e:
        result['error'] = str(e)
        logger.error(f"ğŸ“„ {check_config['name']}: {result['error']}")
        
    except Exception as e:
        result['error'] = str(e)
        logger.error(f"ğŸ’¥ {check_config['name']}: {result['error']}")
    
    return result

def generate_preflight_report(results: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    GÃ©nÃ©rer rapport consolidÃ© des prÃ©-flight checks
    
    Args:
        results: Liste des rÃ©sultats de checks
        
    Returns:
        Dict avec rapport consolidÃ©
    """
    report = {
        'total_checks': len(results),
        'successful_checks': 0,
        'failed_checks': 0,
        'critical_failures': 0,
        'total_duration': 0,
        'pipeline_authorized': False,
        'detailed_results': results,
        'summary': [],
        'recommendations': []
    }
    
    # Analyse des rÃ©sultats
    for i, result in enumerate(results):
        check_config = PREFLIGHT_CHECKS[i]
        report['total_duration'] += result['duration_seconds']
        
        if result['success']:
            report['successful_checks'] += 1
            report['summary'].append(f"âœ… {result['name']}: OK ({result['duration_seconds']:.1f}s)")
        else:
            report['failed_checks'] += 1
            
            if check_config['critical']:
                report['critical_failures'] += 1
            
            error_detail = result['error'] or f"Exit code {result['exit_code']}"
            report['summary'].append(f"âŒ {result['name']}: Ã‰CHEC - {error_detail}")
            
            # Recommandations spÃ©cifiques
            if 'GPU' in result['name']:
                report['recommendations'].append("ğŸ® VÃ©rifier configuration dual-GPU RTX 3090")
                report['recommendations'].append("ğŸ”§ Configurer CUDA_VISIBLE_DEVICES='1'")
            elif 'Audio' in result['name']:
                report['recommendations'].append("ğŸ¤ VÃ©rifier permissions microphone Windows")
                report['recommendations'].append("ğŸ”§ Installer PyAudio: pip install pyaudio")
            elif 'LLM' in result['name']:
                report['recommendations'].append("ğŸ¤– DÃ©marrer serveur LLM (Ollama, LM Studio)")
                report['recommendations'].append("ğŸ”§ TÃ©lÃ©charger modÃ¨le LLM compatible")
    
    # Autorisation pipeline
    report['pipeline_authorized'] = (report['critical_failures'] == 0)
    
    return report

def main():
    """Point d'entrÃ©e principal de l'orchestrateur prÃ©-flight"""
    logger.info("ğŸš€ DÃ‰MARRAGE PRÃ‰-FLIGHT CHECKS PIPELINE COMPLET...")
    
    try:
        # DÃ©termination rÃ©pertoire scripts
        current_dir = Path(__file__).parent
        scripts_dir = current_dir
        
        logger.info(f"ğŸ“‚ RÃ©pertoire scripts: {scripts_dir}")
        
        # VÃ©rification prÃ©sence scripts
        missing_scripts = []
        for check in PREFLIGHT_CHECKS:
            script_path = scripts_dir / check['script']
            if not script_path.exists():
                missing_scripts.append(check['script'])
        
        if missing_scripts:
            raise FileNotFoundError(f"Scripts manquants: {', '.join(missing_scripts)}")
        
        # ExÃ©cution sÃ©quentielle des checks
        results = []
        total_start_time = time.time()
        
        for check_config in PREFLIGHT_CHECKS:
            result = run_preflight_check(check_config, scripts_dir)
            results.append(result)
            
            # ArrÃªt immÃ©diat si check critique Ã©choue
            if not result['success'] and check_config['critical']:
                logger.error(f"ğŸ›‘ Check critique Ã©chouÃ©: {check_config['name']}")
                logger.error("   Pipeline ne peut pas continuer sans validation complÃ¨te")
                break
        
        total_duration = time.time() - total_start_time
        
        # GÃ©nÃ©ration rapport final
        report = generate_preflight_report(results)
        
        # Affichage rapport complet
        print("\n" + "="*80)
        print("ğŸš€ RAPPORT FINAL PRÃ‰-FLIGHT CHECKS PIPELINE SUPERWHISPER V6")
        print("="*80)
        
        print(f"â±ï¸ DurÃ©e totale: {total_duration:.1f}s")
        print(f"ğŸ“Š Checks exÃ©cutÃ©s: {report['total_checks']}")
        print(f"âœ… RÃ©ussis: {report['successful_checks']}")
        print(f"âŒ Ã‰checs: {report['failed_checks']}")
        print(f"ğŸš¨ Ã‰checs critiques: {report['critical_failures']}")
        
        print(f"\nğŸ“‹ RÃ‰SULTATS DÃ‰TAILLÃ‰S:")
        for summary_line in report['summary']:
            print(f"   {summary_line}")
        
        if report['recommendations']:
            print(f"\nğŸ”§ RECOMMANDATIONS:")
            for rec in report['recommendations']:
                print(f"   {rec}")
        
        print("\n" + "="*80)
        if report['pipeline_authorized']:
            print("ğŸ‰ PIPELINE AUTORISÃ‰ - Tous les prÃ©-flight checks rÃ©ussis")
            print("ğŸš€ PrÃªt pour dÃ©marrage infrastructure pipeline complet")
        else:
            print("ğŸ›‘ PIPELINE BLOQUÃ‰ - Corriger Ã©checs critiques avant continuation")
            print("âš ï¸ Configuration environnement requise avant poursuite")
        print("="*80)
        
        # Code de sortie
        return 0 if report['pipeline_authorized'] else 1
        
    except Exception as e:
        print("\n" + "="*80)
        print("ğŸš« Ã‰CHEC ORCHESTRATEUR PRÃ‰-FLIGHT CHECKS")
        print("="*80)
        print(f"âŒ ERREUR: {e}")
        print("\nğŸ”§ ACTIONS REQUISES:")
        print("   - VÃ©rifier prÃ©sence scripts prÃ©-flight")
        print("   - Valider structure rÃ©pertoire PIPELINE/scripts/")
        print("   - Corriger permissions d'exÃ©cution")
        print("="*80)
        print("ğŸ›‘ PIPELINE BLOQUÃ‰ - Corriger configuration avant continuation")
        print("="*80)
        
        return 1

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code) 