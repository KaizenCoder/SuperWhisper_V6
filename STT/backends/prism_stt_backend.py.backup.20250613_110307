#!/usr/bin/env python3
"""
Backend STT utilisant Prism_Whisper2 - SuperWhisper V6
üö® CONFIGURATION GPU: RTX 3090 (CUDA:1) OBLIGATOIRE

Int√©gration du projet Prism_Whisper2 optimis√© pour RTX 3090
Performance cible: 4.5s ‚Üí < 400ms avec optimisations SuperWhisper V6
"""

import os
import sys
import time
import asyncio
import numpy as np
import logging
from typing import Dict, Any, Optional
from pathlib import Path

# =============================================================================
# üö® CONFIGURATION CRITIQUE GPU - RTX 3090 UNIQUEMENT 
# =============================================================================
os.environ['CUDA_VISIBLE_DEVICES'] = '1'        # RTX 3090 24GB EXCLUSIVEMENT
os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'  # Ordre stable des GPU
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:1024'  # Optimisation m√©moire

print("üéÆ SuperWhisper V6 STT - Configuration GPU RTX 3090 (CUDA:1) forc√©e")
print(f"üîí CUDA_VISIBLE_DEVICES: {os.environ.get('CUDA_VISIBLE_DEVICES')}")

# Imports apr√®s configuration GPU
try:
    import torch
    from faster_whisper import WhisperModel
    CUDA_AVAILABLE = torch.cuda.is_available()
except ImportError as e:
    print(f"‚ùå Erreur import: {e}")
    print("Installation requise: pip install faster-whisper torch")
    sys.exit(1)

# Import modules locaux
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from STT.backends.base_stt_backend import BaseSTTBackend, STTResult, validate_rtx3090_mandatory

class PrismSTTBackend(BaseSTTBackend):
    """
    Backend STT Prism_Whisper2 optimis√© RTX 3090 - SuperWhisper V6
    
    Bas√© sur l'analyse de Prism_Whisper2 avec optimisations SuperWhisper V6:
    - faster-whisper avec compute_type="float16" 
    - GPU Memory Optimizer int√©gr√©
    - Cache mod√®les intelligent
    - Performance cible < 400ms pour 5s audio
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialise le backend Prism STT
        
        Args:
            config: Configuration avec model_size, compute_type, etc.
        """
        super().__init__(config)
        
        # Configuration Prism
        self.model_size = config.get('model', 'large-v2')
        self.compute_type = config.get('compute_type', 'float16')
        self.language = config.get('language', 'fr')
        self.beam_size = config.get('beam_size', 5)
        self.vad_filter = config.get('vad_filter', True)
        
        # Mod√®le Whisper
        self.model = None
        self.model_loaded = False
        
        # Optimisations m√©moire (inspir√© Prism_Whisper2)
        self.memory_optimizer = None
        self.pinned_buffers = []
        
        # M√©triques sp√©cifiques Prism
        self.model_load_time = 0.0
        self.warm_up_completed = False
        
        self.logger = self._setup_logging()
        
        # Initialisation
        self._initialize_prism_backend()
    
    def _setup_logging(self) -> logging.Logger:
        """Setup logging pour Prism backend"""
        logger = logging.getLogger(f'PrismSTTBackend_{self.model_size}')
        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - Prism - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logger.setLevel(logging.INFO)
        return logger
    
    def _initialize_prism_backend(self):
        """Initialise le backend Prism avec optimisations RTX 3090"""
        try:
            self.logger.info(f"üöÄ Initialisation Prism STT {self.model_size} sur RTX 3090...")
            
            # Validation GPU obligatoire
            validate_rtx3090_mandatory()
            
            # Chargement mod√®le faster-whisper optimis√©
            start_time = time.time()
            
            self.model = WhisperModel(
                self.model_size,
                device="cuda",  # cuda:0 apr√®s mapping CUDA_VISIBLE_DEVICES='1'
                compute_type=self.compute_type,
                cpu_threads=4,  # Optimisation CPU pour preprocessing
                num_workers=1   # Single worker pour √©viter conflicts GPU
            )
            
            self.model_load_time = time.time() - start_time
            self.model_loaded = True
            
            self.logger.info(f"‚úÖ Mod√®le {self.model_size} charg√© en {self.model_load_time:.2f}s")
            
            # Warm-up GPU avec audio test (inspir√© Prism_Whisper2)
            self._warm_up_model()
            
            # Initialiser optimiseur m√©moire
            self._initialize_memory_optimizer()
            
            self.logger.info("üé§ Backend Prism STT pr√™t sur RTX 3090")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur initialisation Prism: {e}")
            raise RuntimeError(f"√âchec initialisation PrismSTTBackend: {e}")
    
    def _warm_up_model(self):
        """Warm-up mod√®le avec audio test (inspir√© Prism_Whisper2)"""
        try:
            self.logger.info("üî• Warm-up mod√®le Prism...")
            
            # Audio test 3 secondes (comme dans Prism_Whisper2)
            dummy_audio = np.zeros(16000 * 3, dtype=np.float32)
            
            # 3 passes de warm-up
            for i in range(3):
                start_time = time.time()
                segments, _ = self.model.transcribe(
                    dummy_audio,
                    language=self.language,
                    beam_size=self.beam_size,
                    vad_filter=self.vad_filter
                )
                # Consommer les segments pour forcer l'ex√©cution
                list(segments)
                
                warm_up_time = time.time() - start_time
                self.logger.info(f"   Warm-up {i+1}/3: {warm_up_time:.3f}s")
            
            self.warm_up_completed = True
            self.logger.info("‚úÖ Warm-up Prism termin√©")
            
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Warm-up √©chou√©: {e}")
    
    def _initialize_memory_optimizer(self):
        """Initialise optimiseur m√©moire (inspir√© Prism_Whisper2)"""
        try:
            # Pr√©-allocation buffers pinned pour audio
            buffer_sizes = [16000 * 1, 16000 * 3, 16000 * 5, 16000 * 10]  # 1s, 3s, 5s, 10s
            
            for size in buffer_sizes:
                buffer = torch.zeros(size, dtype=torch.float32, pin_memory=True)
                self.pinned_buffers.append({
                    'size': size,
                    'buffer': buffer,
                    'in_use': False
                })
            
            self.logger.info(f"üì¶ {len(self.pinned_buffers)} buffers pinned pr√©-allou√©s")
            
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Optimiseur m√©moire: {e}")
    
    def _get_optimal_buffer(self, audio_size: int) -> Optional[torch.Tensor]:
        """Obtient buffer pinned optimal pour taille audio"""
        best_buffer = None
        best_size_diff = float('inf')
        
        for buffer_info in self.pinned_buffers:
            if (not buffer_info['in_use'] and 
                buffer_info['size'] >= audio_size):
                
                size_diff = buffer_info['size'] - audio_size
                if size_diff < best_size_diff:
                    best_buffer = buffer_info
                    best_size_diff = size_diff
        
        if best_buffer:
            best_buffer['in_use'] = True
            return best_buffer['buffer'][:audio_size]
        
        return None
    
    def _release_buffer(self, buffer: torch.Tensor):
        """Lib√®re buffer pinned"""
        for buffer_info in self.pinned_buffers:
            if torch.equal(buffer_info['buffer'][:len(buffer)], buffer):
                buffer_info['in_use'] = False
                break
    
    async def transcribe(self, audio: np.ndarray) -> STTResult:
        """
        Transcription asynchrone avec optimisations Prism_Whisper2
        
        Args:
            audio: Audio 16kHz mono float32
            
        Returns:
            STTResult avec transcription et m√©triques
        """
        if not self.model_loaded:
            raise RuntimeError("Mod√®le Prism non charg√©")
        
        start_time = time.perf_counter()
        audio_duration = len(audio) / 16000  # secondes
        
        try:
            # Optimisation m√©moire avec buffer pinned
            gpu_buffer = self._get_optimal_buffer(len(audio))
            if gpu_buffer is not None:
                # Copie optimis√©e vers buffer pinned
                gpu_buffer.copy_(torch.from_numpy(audio))
                audio_for_transcription = gpu_buffer.cpu().numpy()
            else:
                # Fallback copie standard
                audio_for_transcription = audio.copy()
            
            # Transcription dans thread s√©par√© (√©viter blocage asyncio)
            result = await asyncio.to_thread(
                self._transcribe_sync,
                audio_for_transcription
            )
            
            # Lib√©rer buffer si utilis√©
            if gpu_buffer is not None:
                self._release_buffer(gpu_buffer)
            
            processing_time = time.perf_counter() - start_time
            rtf = processing_time / audio_duration
            
            # Enregistrer m√©triques
            self._record_request(processing_time, True)
            
            return STTResult(
                text=result['text'],
                confidence=result['confidence'],
                segments=result['segments'],
                processing_time=processing_time,
                device=self.device,
                rtf=rtf,
                backend_used=f"prism_{self.model_size}",
                success=True
            )
            
        except Exception as e:
            processing_time = time.perf_counter() - start_time
            self._record_request(processing_time, False)
            
            self.logger.error(f"‚ùå Erreur transcription Prism: {e}")
            
            return STTResult(
                text="",
                confidence=0.0,
                segments=[],
                processing_time=processing_time,
                device=self.device,
                rtf=999.0,
                backend_used=f"prism_{self.model_size}",
                success=False,
                error=str(e)
            )
    
    def _transcribe_sync(self, audio: np.ndarray) -> Dict[str, Any]:
        """
        Transcription synchrone pour thread - optimis√©e Prism_Whisper2
        
        Args:
            audio: Audio numpy array
            
        Returns:
            Dict avec text, confidence, segments
        """
        try:
            # Transcription avec param√®tres optimis√©s (inspir√© Prism_Whisper2)
            segments, info = self.model.transcribe(
                audio,
                language=self.language,
                beam_size=self.beam_size,
                best_of=5,  # Qualit√© optimale
                vad_filter=self.vad_filter,
                word_timestamps=False,  # Plus rapide sans timestamps mots
                condition_on_previous_text=False  # √âviter d√©pendances contexte
            )
            
            # Extraire texte et segments
            text_parts = []
            segments_list = []
            total_confidence = 0.0
            segment_count = 0
            
            for segment in segments:
                text_parts.append(segment.text)
                segments_list.append({
                    'start': segment.start,
                    'end': segment.end,
                    'text': segment.text,
                    'confidence': getattr(segment, 'avg_logprob', 0.8)  # Fallback confidence
                })
                
                # Calculer confiance moyenne
                if hasattr(segment, 'avg_logprob'):
                    # Convertir log prob en confidence (approximation)
                    confidence = min(1.0, max(0.0, (segment.avg_logprob + 1.0)))
                    total_confidence += confidence
                    segment_count += 1
            
            # Texte final
            final_text = ' '.join(text_parts).strip()
            
            # Confiance moyenne
            avg_confidence = total_confidence / segment_count if segment_count > 0 else 0.8
            
            return {
                'text': final_text,
                'confidence': avg_confidence,
                'segments': segments_list,
                'language': info.language if hasattr(info, 'language') else self.language,
                'language_probability': getattr(info, 'language_probability', 1.0)
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur transcription sync: {e}")
            raise
    
    def health_check(self) -> bool:
        """
        V√©rifie l'√©tat de sant√© du backend Prism
        
        Returns:
            True si le backend est op√©rationnel
        """
        try:
            if not self.model_loaded:
                return False
            
            # Test rapide avec audio court
            test_audio = np.zeros(16000, dtype=np.float32)  # 1s silence
            
            start_time = time.time()
            segments, _ = self.model.transcribe(test_audio, language=self.language)
            list(segments)  # Consommer
            
            health_check_time = time.time() - start_time
            
            # Sant√© OK si < 2s pour 1s audio
            is_healthy = health_check_time < 2.0
            
            if is_healthy:
                self.logger.debug(f"‚úÖ Health check OK: {health_check_time:.3f}s")
            else:
                self.logger.warning(f"‚ö†Ô∏è Health check lent: {health_check_time:.3f}s")
            
            return is_healthy
            
        except Exception as e:
            self.logger.error(f"‚ùå Health check √©chou√©: {e}")
            return False
    
    def get_metrics(self) -> Dict[str, Any]:
        """Retourne m√©triques sp√©cifiques Prism"""
        base_metrics = super().get_metrics()
        
        prism_metrics = {
            "model_size": self.model_size,
            "compute_type": self.compute_type,
            "model_load_time": self.model_load_time,
            "warm_up_completed": self.warm_up_completed,
            "language": self.language,
            "beam_size": self.beam_size,
            "vad_filter": self.vad_filter,
            "pinned_buffers_count": len(self.pinned_buffers),
            "pinned_buffers_in_use": sum(1 for b in self.pinned_buffers if b['in_use'])
        }
        
        # Fusionner m√©triques
        base_metrics.update(prism_metrics)
        return base_metrics
    
    def cleanup(self):
        """Nettoyage ressources Prism"""
        try:
            # Lib√©rer buffers pinned
            for buffer_info in self.pinned_buffers:
                buffer_info['in_use'] = False
            
            # Nettoyer cache GPU
            if torch.cuda.is_available():
                torch.cuda.empty_cache()
            
            self.logger.info("üßπ Nettoyage Prism termin√©")
            
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur nettoyage: {e}")
    
    def __del__(self):
        """Destructeur avec nettoyage"""
        self.cleanup() 