#!/usr/bin/env python3
"""
Validation Setup Pipeline SuperWhisper V6 - Task 18.8
üö® CONFIGURATION GPU: RTX 3090 (CUDA:1) OBLIGATOIRE

Script validation compl√®te utilisant le code OBLIGATOIRE du prompt
"""

import os
import sys
import asyncio
import time
from pathlib import Path
from typing import Optional, Dict, Any
import logging
import yaml

# =============================================================================
# üö® CONFIGURATION CRITIQUE GPU - RTX 3090 UNIQUEMENT 
# =============================================================================
os.environ['CUDA_VISIBLE_DEVICES'] = '1'        # RTX 3090 24GB EXCLUSIVEMENT
os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'  # Ordre stable des GPU
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:1024'

print("üéÆ Validation Setup: RTX 3090 (CUDA:1) forc√©e")
print(f"üîí CUDA_VISIBLE_DEVICES: {os.environ.get('CUDA_VISIBLE_DEVICES')}")

# Ajouter le r√©pertoire parent au path pour imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

# =============================================================================
# IMPORTS ET CONFIGURATION
# =============================================================================

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s ‚Äì %(levelname)s ‚Äì %(name)s ‚Äì %(message)s",
)
LOGGER = logging.getLogger("ValidateSetup")

# =============================================================================
# CLASSE VALIDATION UTILISANT CODE OBLIGATOIRE
# =============================================================================

class PipelineSetupValidator:
    """Validation setup pipeline utilisant le code obligatoire du prompt"""
    
    def __init__(self, config_path: str = "PIPELINE/config/pipeline.yaml"):
        self.config_path = config_path
        self.validation_results = {}
        
    async def run_validation(self):
        """Ex√©cuter validation compl√®te setup"""
        print("\n" + "="*60)
        print("üîç VALIDATION SETUP SUPERWHISPER V6 PIPELINE")
        print("üö® CODE OBLIGATOIRE DU PROMPT UTILIS√â")
        print("="*60)
        
        try:
            # Validation environnement
            await self._validate_environment()
            
            # Validation configuration
            self._validate_configuration()
            
            # Validation composants
            await self._validate_components()
            
            # Test bootstrap obligatoire
            await self._test_bootstrap_obligatoire()
            
            # G√©n√©ration rapport
            self._generate_validation_report()
            
        except Exception as e:
            LOGGER.error(f"‚ùå Erreur validation: {e}")
            print(f"‚ùå Erreur: {e}")
    
    async def _validate_environment(self):
        """Valider environnement syst√®me"""
        print("\nüîç VALIDATION ENVIRONNEMENT")
        print("-" * 30)
        
        # Test GPU RTX 3090
        print("üéÆ Validation GPU RTX 3090...")
        try:
            from PIPELINE.scripts.assert_gpu_env import main as validate_gpu
            validate_gpu()
            self.validation_results["gpu"] = {"status": "‚úÖ PASS", "details": "RTX 3090 valid√©e"}
            print("‚úÖ GPU RTX 3090 valid√©e")
        except Exception as e:
            self.validation_results["gpu"] = {"status": "‚ùå FAIL", "details": str(e)}
            print(f"‚ùå Erreur validation GPU: {e}")
        
        # Test devices audio
        print("üîä Validation devices audio...")
        try:
            from PIPELINE.scripts.validate_audio_devices import main as validate_audio
            validate_audio()
            self.validation_results["audio"] = {"status": "‚úÖ PASS", "details": "Devices audio valid√©s"}
            print("‚úÖ Devices audio valid√©s")
        except Exception as e:
            self.validation_results["audio"] = {"status": "‚ö†Ô∏è WARNING", "details": str(e)}
            print(f"‚ö†Ô∏è Avertissement audio: {e}")
        
        # Test serveur LLM
        print("ü§ñ Test serveur LLM...")
        try:
            from PIPELINE.scripts.start_llm import main as validate_llm
            await validate_llm()
            self.validation_results["llm"] = {"status": "‚úÖ PASS", "details": "Serveur LLM accessible"}
            print("‚úÖ Serveur LLM accessible")
        except Exception as e:
            self.validation_results["llm"] = {"status": "‚ö†Ô∏è WARNING", "details": str(e)}
            print(f"‚ö†Ô∏è Avertissement LLM: {e}")
            print("   Le pipeline utilisera les fallbacks")
    
    def _validate_configuration(self):
        """Valider configuration pipeline"""
        print("\nüìã VALIDATION CONFIGURATION")
        print("-" * 30)
        
        try:
            # V√©rifier fichier configuration
            if not Path(self.config_path).exists():
                self.validation_results["config"] = {
                    "status": "‚ö†Ô∏è WARNING", 
                    "details": f"Configuration non trouv√©e: {self.config_path}"
                }
                print(f"‚ö†Ô∏è Configuration non trouv√©e: {self.config_path}")
                print("üìã Configuration par d√©faut sera utilis√©e")
                return
            
            # Charger et valider configuration
            with open(self.config_path, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
            
            # Valider sections obligatoires
            required_sections = ['stt', 'tts', 'pipeline']
            missing_sections = [s for s in required_sections if s not in config]
            
            if missing_sections:
                self.validation_results["config"] = {
                    "status": "‚ùå FAIL",
                    "details": f"Sections manquantes: {missing_sections}"
                }
                print(f"‚ùå Sections manquantes: {missing_sections}")
            else:
                self.validation_results["config"] = {
                    "status": "‚úÖ PASS",
                    "details": "Configuration compl√®te valid√©e"
                }
                print("‚úÖ Configuration compl√®te valid√©e")
                
                # Afficher d√©tails configuration
                print(f"  üìÅ Fichier: {self.config_path}")
                print(f"  üé§ STT Backend: {config.get('stt', {}).get('primary_backend', 'N/A')}")
                print(f"  üîä TTS Backend: {config.get('tts', {}).get('primary_backend', 'N/A')}")
                print(f"  ü§ñ LLM Endpoint: {config.get('pipeline', {}).get('llm_endpoint', 'N/A')}")
                print(f"  üìä M√©triques: {config.get('pipeline', {}).get('enable_metrics', False)}")
                
        except Exception as e:
            self.validation_results["config"] = {
                "status": "‚ùå FAIL",
                "details": f"Erreur lecture configuration: {e}"
            }
            print(f"‚ùå Erreur lecture configuration: {e}")
    
    async def _validate_components(self):
        """Valider composants pipeline"""
        print("\nüîß VALIDATION COMPOSANTS")
        print("-" * 30)
        
        # Test imports composants
        print("üì¶ Test imports composants...")
        try:
            from STT.unified_stt_manager_optimized import OptimizedUnifiedSTTManager
            from TTS.tts_manager import UnifiedTTSManager
            from PIPELINE.pipeline_orchestrator import PipelineOrchestrator
            
            self.validation_results["imports"] = {
                "status": "‚úÖ PASS",
                "details": "Tous imports r√©ussis"
            }
            print("‚úÖ Imports composants r√©ussis")
            
        except Exception as e:
            self.validation_results["imports"] = {
                "status": "‚ùå FAIL",
                "details": f"Erreur imports: {e}"
            }
            print(f"‚ùå Erreur imports: {e}")
            return
        
        # Test initialisation composants
        print("üîß Test initialisation composants...")
        try:
            # Configuration par d√©faut
            cfg = {}
            if Path(self.config_path).exists():
                cfg = yaml.safe_load(Path(self.config_path).read_text())
            
            # Test STT
            print("  üé§ Initialisation STT...")
            stt = OptimizedUnifiedSTTManager(cfg.get("stt", {}))
            
            # Test TTS
            print("  üîä Initialisation TTS...")
            tts = UnifiedTTSManager(cfg.get("tts", {}))
            
            # Test PipelineOrchestrator
            print("  üöÄ Initialisation Pipeline...")
            orchestrator = PipelineOrchestrator(
                stt,
                tts,
                llm_endpoint=cfg.get("pipeline", {}).get("llm_endpoint", "http://localhost:8000"),
                metrics_enabled=cfg.get("pipeline", {}).get("enable_metrics", False),
            )
            
            self.validation_results["components"] = {
                "status": "‚úÖ PASS",
                "details": "Composants initialis√©s avec succ√®s"
            }
            print("‚úÖ Composants initialis√©s avec succ√®s")
            
        except Exception as e:
            self.validation_results["components"] = {
                "status": "‚ùå FAIL",
                "details": f"Erreur initialisation: {e}"
            }
            print(f"‚ùå Erreur initialisation: {e}")
    
    async def _test_bootstrap_obligatoire(self):
        """Tester fonction bootstrap obligatoire du prompt"""
        print("\nüöÄ TEST BOOTSTRAP OBLIGATOIRE")
        print("-" * 30)
        
        try:
            # Importer fonction bootstrap du prompt
            from PIPELINE.scripts.demo_pipeline import _bootstrap
            
            print("üìã Test fonction _bootstrap() du prompt...")
            
            # Test avec timeout pour √©viter blocage
            try:
                # Cr√©er task avec timeout
                bootstrap_task = asyncio.create_task(_bootstrap(self.config_path))
                await asyncio.wait_for(bootstrap_task, timeout=10.0)
                
                self.validation_results["bootstrap"] = {
                    "status": "‚úÖ PASS",
                    "details": "Bootstrap obligatoire fonctionnel"
                }
                print("‚úÖ Bootstrap obligatoire fonctionnel")
                
            except asyncio.TimeoutError:
                self.validation_results["bootstrap"] = {
                    "status": "‚ö†Ô∏è WARNING",
                    "details": "Bootstrap timeout (normal sans LLM actif)"
                }
                print("‚ö†Ô∏è Bootstrap timeout (normal sans LLM actif)")
                
            except Exception as e:
                self.validation_results["bootstrap"] = {
                    "status": "‚ùå FAIL",
                    "details": f"Erreur bootstrap: {e}"
                }
                print(f"‚ùå Erreur bootstrap: {e}")
                
        except Exception as e:
            self.validation_results["bootstrap"] = {
                "status": "‚ùå FAIL",
                "details": f"Erreur import bootstrap: {e}"
            }
            print(f"‚ùå Erreur import bootstrap: {e}")
    
    def _generate_validation_report(self):
        """G√©n√©rer rapport validation"""
        print("\nüìã RAPPORT VALIDATION")
        print("="*40)
        
        # Compter r√©sultats
        total_tests = len(self.validation_results)
        passed_tests = sum(1 for r in self.validation_results.values() if r["status"].startswith("‚úÖ"))
        warning_tests = sum(1 for r in self.validation_results.values() if r["status"].startswith("‚ö†Ô∏è"))
        failed_tests = sum(1 for r in self.validation_results.values() if r["status"].startswith("‚ùå"))
        
        # Afficher r√©sum√©
        print(f"üìä R√âSUM√â VALIDATION:")
        print(f"  Total tests: {total_tests}")
        print(f"  ‚úÖ R√©ussis: {passed_tests}")
        print(f"  ‚ö†Ô∏è Avertissements: {warning_tests}")
        print(f"  ‚ùå √âchecs: {failed_tests}")
        
        # Afficher d√©tails
        print(f"\nüìã D√âTAILS:")
        for test_name, result in self.validation_results.items():
            print(f"  {result['status']} {test_name.upper()}: {result['details']}")
        
        # Statut global
        if failed_tests == 0:
            if warning_tests == 0:
                print(f"\nüéâ VALIDATION COMPL√àTE R√âUSSIE")
                print("‚úÖ Pipeline pr√™t pour tests end-to-end")
            else:
                print(f"\n‚úÖ VALIDATION R√âUSSIE AVEC AVERTISSEMENTS")
                print("‚ö†Ô∏è Pipeline fonctionnel avec limitations")
        else:
            print(f"\n‚ùå VALIDATION √âCHOU√âE")
            print("üîß Corrections requises avant tests")
        
        # Sauvegarder rapport
        report_path = "PIPELINE/reports/validation_setup.json"
        Path(report_path).parent.mkdir(parents=True, exist_ok=True)
        
        import json
        from datetime import datetime
        
        report = {
            "timestamp": datetime.now().isoformat(),
            "pipeline_version": "SuperWhisper V6",
            "gpu_config": "RTX 3090 (CUDA:1)",
            "code_version": "Prompt Obligatoire v1.1",
            "total_tests": total_tests,
            "passed_tests": passed_tests,
            "warning_tests": warning_tests,
            "failed_tests": failed_tests,
            "results": self.validation_results
        }
        
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print(f"\nüìÅ Rapport sauvegard√©: {report_path}")

# =============================================================================
# SCRIPT ENTRY POINT
# =============================================================================

async def main():
    """Point d'entr√©e principal"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Validation Setup Pipeline SuperWhisper V6")
    parser.add_argument("--config", "-c", type=str, default="PIPELINE/config/pipeline.yaml",
                       help="Chemin configuration YAML")
    
    args = parser.parse_args()
    
    validator = PipelineSetupValidator(args.config)
    await validator.run_validation()

if __name__ == "__main__":
    try:
        # Optimisation uvloop comme dans le prompt obligatoire
        try:
            import uvloop
            uvloop.install()
            LOGGER.info("‚úÖ uvloop enabled for enhanced performance")
        except ImportError:
            LOGGER.info("uvloop not available ‚Äì fallback to asyncio event‚Äëloop")

        # D√©marrer validation
        asyncio.run(main())
    except KeyboardInterrupt:
        LOGGER.info("üëã Keyboard interrupt ‚Äì exit")
    except Exception as e:
        LOGGER.error("‚ùå Validation startup error: %s", e)
        sys.exit(1) 